# Identity System Documentation

## Overview

The Nakama identity system uses a **device-based** approach combined with **per-game segmentation** to manage user identities across multiple games in the ecosystem.

## Key Concepts

### Device ID

Each player is identified by a unique device identifier (`device_id`). This ID is:
- Generated by the Unity client (can be `SystemInfo.deviceUniqueIdentifier` or a custom UUID)
- Persistent across app sessions
- Used as the primary identifier for the player

### Game ID

Each game in the ecosystem has a unique UUID (`game_id`). This allows:
- Per-game player profiles
- Isolated game progression
- Shared global identity across games

### Identity Structure

Each identity is stored with the following key pattern:
```
Collection: "quizverse"
Key: "identity:<device_id>:<game_id>"
```

## Identity Object

```json
{
  "username": "PlayerName",
  "device_id": "unique-device-identifier",
  "game_id": "game-uuid",
  "wallet_id": "per-game-wallet-uuid",
  "global_wallet_id": "global:device-id",
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:00:00Z"
}
```

## Creating or Syncing Identity

### RPC: `create_or_sync_user`

This RPC creates a new identity or retrieves an existing one.

**Input:**
```json
{
  "username": "PlayerName",
  "device_id": "unique-device-identifier",
  "game_id": "your-game-uuid"
}
```

**Response (New User):**
```json
{
  "success": true,
  "created": true,
  "username": "PlayerName",
  "device_id": "unique-device-identifier",
  "game_id": "your-game-uuid",
  "wallet_id": "generated-wallet-uuid",
  "global_wallet_id": "global:unique-device-identifier"
}
```

**Response (Existing User):**
```json
{
  "success": true,
  "created": false,
  "username": "PlayerName",
  "device_id": "unique-device-identifier",
  "game_id": "your-game-uuid",
  "wallet_id": "existing-wallet-uuid",
  "global_wallet_id": "global:unique-device-identifier"
}
```

## Unity Implementation

### Generating Device ID

```csharp
using UnityEngine;

public class DeviceIdentity
{
    public static string GetDeviceId()
    {
        // Option 1: Use Unity's built-in device ID
        string deviceId = SystemInfo.deviceUniqueIdentifier;
        
        // Option 2: Generate and persist custom ID
        if (!PlayerPrefs.HasKey("custom_device_id"))
        {
            deviceId = System.Guid.NewGuid().ToString();
            PlayerPrefs.SetString("custom_device_id", deviceId);
            PlayerPrefs.Save();
        }
        else
        {
            deviceId = PlayerPrefs.GetString("custom_device_id");
        }
        
        return deviceId;
    }
}
```

### Calling create_or_sync_user

```csharp
using Nakama;
using System.Threading.Tasks;
using UnityEngine;

public class NakamaIdentity
{
    private IClient client;
    private ISession session;
    private string gameId = "your-game-uuid"; // Replace with your game ID
    
    public async Task<string> CreateOrSyncUser(string username)
    {
        string deviceId = DeviceIdentity.GetDeviceId();
        
        var payload = new Dictionary<string, object>
        {
            { "username", username },
            { "device_id", deviceId },
            { "game_id", gameId }
        };
        
        var payloadJson = JsonUtility.ToJson(payload);
        var result = await client.RpcAsync(session, "create_or_sync_user", payloadJson);
        
        Debug.Log("Identity result: " + result.Payload);
        return result.Payload;
    }
}
```

## Storage Layout

### Collection: `quizverse`

| Key Pattern | Description | Example |
|------------|-------------|---------|
| `identity:<device_id>:<game_id>` | Per-game identity | `identity:abc123:game-uuid-1` |

## Best Practices

1. **Call on First Launch**: Always call `create_or_sync_user` when the game starts
2. **Cache Locally**: Store the identity response locally to avoid repeated calls
3. **Consistent Device ID**: Use the same device ID generation method throughout your game
4. **Username Updates**: Call `create_or_sync_user` again if the player changes their username
5. **Multi-Game Support**: Use different game IDs for different games to maintain separate identities

## Username Synchronization

When a new identity is created, the system automatically updates the Nakama built-in username to match. This ensures:
- Consistency across the platform
- Proper display names in leaderboards
- Integration with Nakama's native features

## Error Handling

### Missing Fields Error
```json
{
  "success": false,
  "error": "Missing required fields: username, device_id, game_id"
}
```

**Solution**: Ensure all three fields are provided in the request.

### Invalid JSON Error
```json
{
  "success": false,
  "error": "Invalid JSON payload"
}
```

**Solution**: Check that your JSON is properly formatted.

## Security Considerations

1. **Device ID Spoofing**: Device IDs can be spoofed. For sensitive operations, combine with additional authentication.
2. **Username Validation**: Implement client-side validation for usernames (length, allowed characters, profanity filtering).
3. **Rate Limiting**: Consider implementing rate limiting on identity creation to prevent abuse.

## Migration from Other Systems

If you're migrating from another identity system:

1. Map your existing user IDs to device IDs
2. Call `create_or_sync_user` for each user during migration
3. Store the wallet IDs in your migration mapping table
4. Update your game client to use the new device ID system

## See Also

- [Wallet System](./wallets.md)
- [Unity Quick Start](./unity/Unity-Quick-Start.md)
- [API Reference](./api/README.md)
