// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rtapi/realtime.proto

package rtapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"
import wrappers "github.com/golang/protobuf/ptypes/wrappers"
import api "github.com/heroiclabs/nakama/api"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The type of chat channel.
type ChannelJoin_Type int32

const (
	// Default case. Assumed as ROOM type.
	ChannelJoin_TYPE_UNSPECIFIED ChannelJoin_Type = 0
	// A room which anyone can join to chat.
	ChannelJoin_ROOM ChannelJoin_Type = 1
	// A private channel for 1-on-1 chat.
	ChannelJoin_DIRECT_MESSAGE ChannelJoin_Type = 2
	// A channel for group chat.
	ChannelJoin_GROUP ChannelJoin_Type = 3
)

var ChannelJoin_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "ROOM",
	2: "DIRECT_MESSAGE",
	3: "GROUP",
}
var ChannelJoin_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED": 0,
	"ROOM":             1,
	"DIRECT_MESSAGE":   2,
	"GROUP":            3,
}

func (x ChannelJoin_Type) String() string {
	return proto.EnumName(ChannelJoin_Type_name, int32(x))
}
func (ChannelJoin_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{2, 0}
}

// The selection of possible error codes.
type Error_Code int32

const (
	// An unexpected result from the server.
	Error_RUNTIME_EXCEPTION Error_Code = 0
	// The server received a message which is not recognised.
	Error_UNRECOGNIZED_PAYLOAD Error_Code = 1
	// A message was expected but contains no content.
	Error_MISSING_PAYLOAD Error_Code = 2
	// Fields in the message have an invalid format.
	Error_BAD_INPUT Error_Code = 3
	// The match id was not found.
	Error_MATCH_NOT_FOUND Error_Code = 4
	// The match join was rejected.
	Error_MATCH_JOIN_REJECTED Error_Code = 5
	// The runtime function does not exist on the server.
	Error_RUNTIME_FUNCTION_NOT_FOUND Error_Code = 6
	// The runtime function executed with an error.
	Error_RUNTIME_FUNCTION_EXCEPTION Error_Code = 7
)

var Error_Code_name = map[int32]string{
	0: "RUNTIME_EXCEPTION",
	1: "UNRECOGNIZED_PAYLOAD",
	2: "MISSING_PAYLOAD",
	3: "BAD_INPUT",
	4: "MATCH_NOT_FOUND",
	5: "MATCH_JOIN_REJECTED",
	6: "RUNTIME_FUNCTION_NOT_FOUND",
	7: "RUNTIME_FUNCTION_EXCEPTION",
}
var Error_Code_value = map[string]int32{
	"RUNTIME_EXCEPTION":          0,
	"UNRECOGNIZED_PAYLOAD":       1,
	"MISSING_PAYLOAD":            2,
	"BAD_INPUT":                  3,
	"MATCH_NOT_FOUND":            4,
	"MATCH_JOIN_REJECTED":        5,
	"RUNTIME_FUNCTION_NOT_FOUND": 6,
	"RUNTIME_FUNCTION_EXCEPTION": 7,
}

func (x Error_Code) String() string {
	return proto.EnumName(Error_Code_name, int32(x))
}
func (Error_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{9, 0}
}

// An envelope for a realtime message.
type Envelope struct {
	Cid string `protobuf:"bytes,1,opt,name=cid,proto3" json:"cid,omitempty"`
	// Types that are valid to be assigned to Message:
	//	*Envelope_Channel
	//	*Envelope_ChannelJoin
	//	*Envelope_ChannelLeave
	//	*Envelope_ChannelMessage
	//	*Envelope_ChannelMessageAck
	//	*Envelope_ChannelMessageSend
	//	*Envelope_ChannelMessageUpdate
	//	*Envelope_ChannelMessageRemove
	//	*Envelope_ChannelPresenceEvent
	//	*Envelope_Error
	//	*Envelope_Match
	//	*Envelope_MatchCreate
	//	*Envelope_MatchData
	//	*Envelope_MatchDataSend
	//	*Envelope_MatchJoin
	//	*Envelope_MatchLeave
	//	*Envelope_MatchPresenceEvent
	//	*Envelope_MatchmakerAdd
	//	*Envelope_MatchmakerMatched
	//	*Envelope_MatchmakerRemove
	//	*Envelope_MatchmakerTicket
	//	*Envelope_Notifications
	//	*Envelope_Rpc
	//	*Envelope_Status
	//	*Envelope_StatusFollow
	//	*Envelope_StatusPresenceEvent
	//	*Envelope_StatusUnfollow
	//	*Envelope_StatusUpdate
	//	*Envelope_StreamData
	//	*Envelope_StreamPresenceEvent
	Message              isEnvelope_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{0}
}
func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Envelope.Unmarshal(m, b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
}
func (dst *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(dst, src)
}
func (m *Envelope) XXX_Size() int {
	return xxx_messageInfo_Envelope.Size(m)
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

type isEnvelope_Message interface {
	isEnvelope_Message()
}

type Envelope_Channel struct {
	Channel *Channel `protobuf:"bytes,2,opt,name=channel,proto3,oneof"`
}
type Envelope_ChannelJoin struct {
	ChannelJoin *ChannelJoin `protobuf:"bytes,3,opt,name=channel_join,json=channelJoin,proto3,oneof"`
}
type Envelope_ChannelLeave struct {
	ChannelLeave *ChannelLeave `protobuf:"bytes,4,opt,name=channel_leave,json=channelLeave,proto3,oneof"`
}
type Envelope_ChannelMessage struct {
	ChannelMessage *api.ChannelMessage `protobuf:"bytes,5,opt,name=channel_message,json=channelMessage,proto3,oneof"`
}
type Envelope_ChannelMessageAck struct {
	ChannelMessageAck *ChannelMessageAck `protobuf:"bytes,6,opt,name=channel_message_ack,json=channelMessageAck,proto3,oneof"`
}
type Envelope_ChannelMessageSend struct {
	ChannelMessageSend *ChannelMessageSend `protobuf:"bytes,7,opt,name=channel_message_send,json=channelMessageSend,proto3,oneof"`
}
type Envelope_ChannelMessageUpdate struct {
	ChannelMessageUpdate *ChannelMessageUpdate `protobuf:"bytes,8,opt,name=channel_message_update,json=channelMessageUpdate,proto3,oneof"`
}
type Envelope_ChannelMessageRemove struct {
	ChannelMessageRemove *ChannelMessageRemove `protobuf:"bytes,9,opt,name=channel_message_remove,json=channelMessageRemove,proto3,oneof"`
}
type Envelope_ChannelPresenceEvent struct {
	ChannelPresenceEvent *ChannelPresenceEvent `protobuf:"bytes,10,opt,name=channel_presence_event,json=channelPresenceEvent,proto3,oneof"`
}
type Envelope_Error struct {
	Error *Error `protobuf:"bytes,11,opt,name=error,proto3,oneof"`
}
type Envelope_Match struct {
	Match *Match `protobuf:"bytes,12,opt,name=match,proto3,oneof"`
}
type Envelope_MatchCreate struct {
	MatchCreate *MatchCreate `protobuf:"bytes,13,opt,name=match_create,json=matchCreate,proto3,oneof"`
}
type Envelope_MatchData struct {
	MatchData *MatchData `protobuf:"bytes,14,opt,name=match_data,json=matchData,proto3,oneof"`
}
type Envelope_MatchDataSend struct {
	MatchDataSend *MatchDataSend `protobuf:"bytes,15,opt,name=match_data_send,json=matchDataSend,proto3,oneof"`
}
type Envelope_MatchJoin struct {
	MatchJoin *MatchJoin `protobuf:"bytes,16,opt,name=match_join,json=matchJoin,proto3,oneof"`
}
type Envelope_MatchLeave struct {
	MatchLeave *MatchLeave `protobuf:"bytes,17,opt,name=match_leave,json=matchLeave,proto3,oneof"`
}
type Envelope_MatchPresenceEvent struct {
	MatchPresenceEvent *MatchPresenceEvent `protobuf:"bytes,18,opt,name=match_presence_event,json=matchPresenceEvent,proto3,oneof"`
}
type Envelope_MatchmakerAdd struct {
	MatchmakerAdd *MatchmakerAdd `protobuf:"bytes,19,opt,name=matchmaker_add,json=matchmakerAdd,proto3,oneof"`
}
type Envelope_MatchmakerMatched struct {
	MatchmakerMatched *MatchmakerMatched `protobuf:"bytes,20,opt,name=matchmaker_matched,json=matchmakerMatched,proto3,oneof"`
}
type Envelope_MatchmakerRemove struct {
	MatchmakerRemove *MatchmakerRemove `protobuf:"bytes,21,opt,name=matchmaker_remove,json=matchmakerRemove,proto3,oneof"`
}
type Envelope_MatchmakerTicket struct {
	MatchmakerTicket *MatchmakerTicket `protobuf:"bytes,22,opt,name=matchmaker_ticket,json=matchmakerTicket,proto3,oneof"`
}
type Envelope_Notifications struct {
	Notifications *Notifications `protobuf:"bytes,23,opt,name=notifications,proto3,oneof"`
}
type Envelope_Rpc struct {
	Rpc *api.Rpc `protobuf:"bytes,24,opt,name=rpc,proto3,oneof"`
}
type Envelope_Status struct {
	Status *Status `protobuf:"bytes,25,opt,name=status,proto3,oneof"`
}
type Envelope_StatusFollow struct {
	StatusFollow *StatusFollow `protobuf:"bytes,26,opt,name=status_follow,json=statusFollow,proto3,oneof"`
}
type Envelope_StatusPresenceEvent struct {
	StatusPresenceEvent *StatusPresenceEvent `protobuf:"bytes,27,opt,name=status_presence_event,json=statusPresenceEvent,proto3,oneof"`
}
type Envelope_StatusUnfollow struct {
	StatusUnfollow *StatusUnfollow `protobuf:"bytes,28,opt,name=status_unfollow,json=statusUnfollow,proto3,oneof"`
}
type Envelope_StatusUpdate struct {
	StatusUpdate *StatusUpdate `protobuf:"bytes,29,opt,name=status_update,json=statusUpdate,proto3,oneof"`
}
type Envelope_StreamData struct {
	StreamData *StreamData `protobuf:"bytes,30,opt,name=stream_data,json=streamData,proto3,oneof"`
}
type Envelope_StreamPresenceEvent struct {
	StreamPresenceEvent *StreamPresenceEvent `protobuf:"bytes,31,opt,name=stream_presence_event,json=streamPresenceEvent,proto3,oneof"`
}

func (*Envelope_Channel) isEnvelope_Message()              {}
func (*Envelope_ChannelJoin) isEnvelope_Message()          {}
func (*Envelope_ChannelLeave) isEnvelope_Message()         {}
func (*Envelope_ChannelMessage) isEnvelope_Message()       {}
func (*Envelope_ChannelMessageAck) isEnvelope_Message()    {}
func (*Envelope_ChannelMessageSend) isEnvelope_Message()   {}
func (*Envelope_ChannelMessageUpdate) isEnvelope_Message() {}
func (*Envelope_ChannelMessageRemove) isEnvelope_Message() {}
func (*Envelope_ChannelPresenceEvent) isEnvelope_Message() {}
func (*Envelope_Error) isEnvelope_Message()                {}
func (*Envelope_Match) isEnvelope_Message()                {}
func (*Envelope_MatchCreate) isEnvelope_Message()          {}
func (*Envelope_MatchData) isEnvelope_Message()            {}
func (*Envelope_MatchDataSend) isEnvelope_Message()        {}
func (*Envelope_MatchJoin) isEnvelope_Message()            {}
func (*Envelope_MatchLeave) isEnvelope_Message()           {}
func (*Envelope_MatchPresenceEvent) isEnvelope_Message()   {}
func (*Envelope_MatchmakerAdd) isEnvelope_Message()        {}
func (*Envelope_MatchmakerMatched) isEnvelope_Message()    {}
func (*Envelope_MatchmakerRemove) isEnvelope_Message()     {}
func (*Envelope_MatchmakerTicket) isEnvelope_Message()     {}
func (*Envelope_Notifications) isEnvelope_Message()        {}
func (*Envelope_Rpc) isEnvelope_Message()                  {}
func (*Envelope_Status) isEnvelope_Message()               {}
func (*Envelope_StatusFollow) isEnvelope_Message()         {}
func (*Envelope_StatusPresenceEvent) isEnvelope_Message()  {}
func (*Envelope_StatusUnfollow) isEnvelope_Message()       {}
func (*Envelope_StatusUpdate) isEnvelope_Message()         {}
func (*Envelope_StreamData) isEnvelope_Message()           {}
func (*Envelope_StreamPresenceEvent) isEnvelope_Message()  {}

func (m *Envelope) GetMessage() isEnvelope_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Envelope) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *Envelope) GetChannel() *Channel {
	if x, ok := m.GetMessage().(*Envelope_Channel); ok {
		return x.Channel
	}
	return nil
}

func (m *Envelope) GetChannelJoin() *ChannelJoin {
	if x, ok := m.GetMessage().(*Envelope_ChannelJoin); ok {
		return x.ChannelJoin
	}
	return nil
}

func (m *Envelope) GetChannelLeave() *ChannelLeave {
	if x, ok := m.GetMessage().(*Envelope_ChannelLeave); ok {
		return x.ChannelLeave
	}
	return nil
}

func (m *Envelope) GetChannelMessage() *api.ChannelMessage {
	if x, ok := m.GetMessage().(*Envelope_ChannelMessage); ok {
		return x.ChannelMessage
	}
	return nil
}

func (m *Envelope) GetChannelMessageAck() *ChannelMessageAck {
	if x, ok := m.GetMessage().(*Envelope_ChannelMessageAck); ok {
		return x.ChannelMessageAck
	}
	return nil
}

func (m *Envelope) GetChannelMessageSend() *ChannelMessageSend {
	if x, ok := m.GetMessage().(*Envelope_ChannelMessageSend); ok {
		return x.ChannelMessageSend
	}
	return nil
}

func (m *Envelope) GetChannelMessageUpdate() *ChannelMessageUpdate {
	if x, ok := m.GetMessage().(*Envelope_ChannelMessageUpdate); ok {
		return x.ChannelMessageUpdate
	}
	return nil
}

func (m *Envelope) GetChannelMessageRemove() *ChannelMessageRemove {
	if x, ok := m.GetMessage().(*Envelope_ChannelMessageRemove); ok {
		return x.ChannelMessageRemove
	}
	return nil
}

func (m *Envelope) GetChannelPresenceEvent() *ChannelPresenceEvent {
	if x, ok := m.GetMessage().(*Envelope_ChannelPresenceEvent); ok {
		return x.ChannelPresenceEvent
	}
	return nil
}

func (m *Envelope) GetError() *Error {
	if x, ok := m.GetMessage().(*Envelope_Error); ok {
		return x.Error
	}
	return nil
}

func (m *Envelope) GetMatch() *Match {
	if x, ok := m.GetMessage().(*Envelope_Match); ok {
		return x.Match
	}
	return nil
}

func (m *Envelope) GetMatchCreate() *MatchCreate {
	if x, ok := m.GetMessage().(*Envelope_MatchCreate); ok {
		return x.MatchCreate
	}
	return nil
}

func (m *Envelope) GetMatchData() *MatchData {
	if x, ok := m.GetMessage().(*Envelope_MatchData); ok {
		return x.MatchData
	}
	return nil
}

func (m *Envelope) GetMatchDataSend() *MatchDataSend {
	if x, ok := m.GetMessage().(*Envelope_MatchDataSend); ok {
		return x.MatchDataSend
	}
	return nil
}

func (m *Envelope) GetMatchJoin() *MatchJoin {
	if x, ok := m.GetMessage().(*Envelope_MatchJoin); ok {
		return x.MatchJoin
	}
	return nil
}

func (m *Envelope) GetMatchLeave() *MatchLeave {
	if x, ok := m.GetMessage().(*Envelope_MatchLeave); ok {
		return x.MatchLeave
	}
	return nil
}

func (m *Envelope) GetMatchPresenceEvent() *MatchPresenceEvent {
	if x, ok := m.GetMessage().(*Envelope_MatchPresenceEvent); ok {
		return x.MatchPresenceEvent
	}
	return nil
}

func (m *Envelope) GetMatchmakerAdd() *MatchmakerAdd {
	if x, ok := m.GetMessage().(*Envelope_MatchmakerAdd); ok {
		return x.MatchmakerAdd
	}
	return nil
}

func (m *Envelope) GetMatchmakerMatched() *MatchmakerMatched {
	if x, ok := m.GetMessage().(*Envelope_MatchmakerMatched); ok {
		return x.MatchmakerMatched
	}
	return nil
}

func (m *Envelope) GetMatchmakerRemove() *MatchmakerRemove {
	if x, ok := m.GetMessage().(*Envelope_MatchmakerRemove); ok {
		return x.MatchmakerRemove
	}
	return nil
}

func (m *Envelope) GetMatchmakerTicket() *MatchmakerTicket {
	if x, ok := m.GetMessage().(*Envelope_MatchmakerTicket); ok {
		return x.MatchmakerTicket
	}
	return nil
}

func (m *Envelope) GetNotifications() *Notifications {
	if x, ok := m.GetMessage().(*Envelope_Notifications); ok {
		return x.Notifications
	}
	return nil
}

func (m *Envelope) GetRpc() *api.Rpc {
	if x, ok := m.GetMessage().(*Envelope_Rpc); ok {
		return x.Rpc
	}
	return nil
}

func (m *Envelope) GetStatus() *Status {
	if x, ok := m.GetMessage().(*Envelope_Status); ok {
		return x.Status
	}
	return nil
}

func (m *Envelope) GetStatusFollow() *StatusFollow {
	if x, ok := m.GetMessage().(*Envelope_StatusFollow); ok {
		return x.StatusFollow
	}
	return nil
}

func (m *Envelope) GetStatusPresenceEvent() *StatusPresenceEvent {
	if x, ok := m.GetMessage().(*Envelope_StatusPresenceEvent); ok {
		return x.StatusPresenceEvent
	}
	return nil
}

func (m *Envelope) GetStatusUnfollow() *StatusUnfollow {
	if x, ok := m.GetMessage().(*Envelope_StatusUnfollow); ok {
		return x.StatusUnfollow
	}
	return nil
}

func (m *Envelope) GetStatusUpdate() *StatusUpdate {
	if x, ok := m.GetMessage().(*Envelope_StatusUpdate); ok {
		return x.StatusUpdate
	}
	return nil
}

func (m *Envelope) GetStreamData() *StreamData {
	if x, ok := m.GetMessage().(*Envelope_StreamData); ok {
		return x.StreamData
	}
	return nil
}

func (m *Envelope) GetStreamPresenceEvent() *StreamPresenceEvent {
	if x, ok := m.GetMessage().(*Envelope_StreamPresenceEvent); ok {
		return x.StreamPresenceEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Envelope) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Envelope_OneofMarshaler, _Envelope_OneofUnmarshaler, _Envelope_OneofSizer, []interface{}{
		(*Envelope_Channel)(nil),
		(*Envelope_ChannelJoin)(nil),
		(*Envelope_ChannelLeave)(nil),
		(*Envelope_ChannelMessage)(nil),
		(*Envelope_ChannelMessageAck)(nil),
		(*Envelope_ChannelMessageSend)(nil),
		(*Envelope_ChannelMessageUpdate)(nil),
		(*Envelope_ChannelMessageRemove)(nil),
		(*Envelope_ChannelPresenceEvent)(nil),
		(*Envelope_Error)(nil),
		(*Envelope_Match)(nil),
		(*Envelope_MatchCreate)(nil),
		(*Envelope_MatchData)(nil),
		(*Envelope_MatchDataSend)(nil),
		(*Envelope_MatchJoin)(nil),
		(*Envelope_MatchLeave)(nil),
		(*Envelope_MatchPresenceEvent)(nil),
		(*Envelope_MatchmakerAdd)(nil),
		(*Envelope_MatchmakerMatched)(nil),
		(*Envelope_MatchmakerRemove)(nil),
		(*Envelope_MatchmakerTicket)(nil),
		(*Envelope_Notifications)(nil),
		(*Envelope_Rpc)(nil),
		(*Envelope_Status)(nil),
		(*Envelope_StatusFollow)(nil),
		(*Envelope_StatusPresenceEvent)(nil),
		(*Envelope_StatusUnfollow)(nil),
		(*Envelope_StatusUpdate)(nil),
		(*Envelope_StreamData)(nil),
		(*Envelope_StreamPresenceEvent)(nil),
	}
}

func _Envelope_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Envelope)
	// message
	switch x := m.Message.(type) {
	case *Envelope_Channel:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Channel); err != nil {
			return err
		}
	case *Envelope_ChannelJoin:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelJoin); err != nil {
			return err
		}
	case *Envelope_ChannelLeave:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelLeave); err != nil {
			return err
		}
	case *Envelope_ChannelMessage:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelMessage); err != nil {
			return err
		}
	case *Envelope_ChannelMessageAck:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelMessageAck); err != nil {
			return err
		}
	case *Envelope_ChannelMessageSend:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelMessageSend); err != nil {
			return err
		}
	case *Envelope_ChannelMessageUpdate:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelMessageUpdate); err != nil {
			return err
		}
	case *Envelope_ChannelMessageRemove:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelMessageRemove); err != nil {
			return err
		}
	case *Envelope_ChannelPresenceEvent:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChannelPresenceEvent); err != nil {
			return err
		}
	case *Envelope_Error:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *Envelope_Match:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Match); err != nil {
			return err
		}
	case *Envelope_MatchCreate:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchCreate); err != nil {
			return err
		}
	case *Envelope_MatchData:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchData); err != nil {
			return err
		}
	case *Envelope_MatchDataSend:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchDataSend); err != nil {
			return err
		}
	case *Envelope_MatchJoin:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchJoin); err != nil {
			return err
		}
	case *Envelope_MatchLeave:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchLeave); err != nil {
			return err
		}
	case *Envelope_MatchPresenceEvent:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchPresenceEvent); err != nil {
			return err
		}
	case *Envelope_MatchmakerAdd:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchmakerAdd); err != nil {
			return err
		}
	case *Envelope_MatchmakerMatched:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchmakerMatched); err != nil {
			return err
		}
	case *Envelope_MatchmakerRemove:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchmakerRemove); err != nil {
			return err
		}
	case *Envelope_MatchmakerTicket:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MatchmakerTicket); err != nil {
			return err
		}
	case *Envelope_Notifications:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Notifications); err != nil {
			return err
		}
	case *Envelope_Rpc:
		b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rpc); err != nil {
			return err
		}
	case *Envelope_Status:
		b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Status); err != nil {
			return err
		}
	case *Envelope_StatusFollow:
		b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusFollow); err != nil {
			return err
		}
	case *Envelope_StatusPresenceEvent:
		b.EncodeVarint(27<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusPresenceEvent); err != nil {
			return err
		}
	case *Envelope_StatusUnfollow:
		b.EncodeVarint(28<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusUnfollow); err != nil {
			return err
		}
	case *Envelope_StatusUpdate:
		b.EncodeVarint(29<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusUpdate); err != nil {
			return err
		}
	case *Envelope_StreamData:
		b.EncodeVarint(30<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamData); err != nil {
			return err
		}
	case *Envelope_StreamPresenceEvent:
		b.EncodeVarint(31<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamPresenceEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Envelope.Message has unexpected type %T", x)
	}
	return nil
}

func _Envelope_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Envelope)
	switch tag {
	case 2: // message.channel
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Channel)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Channel{msg}
		return true, err
	case 3: // message.channel_join
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelJoin)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelJoin{msg}
		return true, err
	case 4: // message.channel_leave
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelLeave)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelLeave{msg}
		return true, err
	case 5: // message.channel_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(api.ChannelMessage)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelMessage{msg}
		return true, err
	case 6: // message.channel_message_ack
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelMessageAck)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelMessageAck{msg}
		return true, err
	case 7: // message.channel_message_send
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelMessageSend)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelMessageSend{msg}
		return true, err
	case 8: // message.channel_message_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelMessageUpdate)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelMessageUpdate{msg}
		return true, err
	case 9: // message.channel_message_remove
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelMessageRemove)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelMessageRemove{msg}
		return true, err
	case 10: // message.channel_presence_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelPresenceEvent)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_ChannelPresenceEvent{msg}
		return true, err
	case 11: // message.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Error{msg}
		return true, err
	case 12: // message.match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Match)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Match{msg}
		return true, err
	case 13: // message.match_create
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchCreate)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchCreate{msg}
		return true, err
	case 14: // message.match_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchData)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchData{msg}
		return true, err
	case 15: // message.match_data_send
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchDataSend)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchDataSend{msg}
		return true, err
	case 16: // message.match_join
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchJoin)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchJoin{msg}
		return true, err
	case 17: // message.match_leave
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchLeave)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchLeave{msg}
		return true, err
	case 18: // message.match_presence_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchPresenceEvent)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchPresenceEvent{msg}
		return true, err
	case 19: // message.matchmaker_add
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchmakerAdd)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchmakerAdd{msg}
		return true, err
	case 20: // message.matchmaker_matched
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchmakerMatched)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchmakerMatched{msg}
		return true, err
	case 21: // message.matchmaker_remove
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchmakerRemove)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchmakerRemove{msg}
		return true, err
	case 22: // message.matchmaker_ticket
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MatchmakerTicket)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_MatchmakerTicket{msg}
		return true, err
	case 23: // message.notifications
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Notifications)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Notifications{msg}
		return true, err
	case 24: // message.rpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(api.Rpc)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Rpc{msg}
		return true, err
	case 25: // message.status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Status)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Status{msg}
		return true, err
	case 26: // message.status_follow
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusFollow)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StatusFollow{msg}
		return true, err
	case 27: // message.status_presence_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusPresenceEvent)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StatusPresenceEvent{msg}
		return true, err
	case 28: // message.status_unfollow
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusUnfollow)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StatusUnfollow{msg}
		return true, err
	case 29: // message.status_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusUpdate)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StatusUpdate{msg}
		return true, err
	case 30: // message.stream_data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamData)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StreamData{msg}
		return true, err
	case 31: // message.stream_presence_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamPresenceEvent)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_StreamPresenceEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Envelope_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Envelope)
	// message
	switch x := m.Message.(type) {
	case *Envelope_Channel:
		s := proto.Size(x.Channel)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelJoin:
		s := proto.Size(x.ChannelJoin)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelLeave:
		s := proto.Size(x.ChannelLeave)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelMessage:
		s := proto.Size(x.ChannelMessage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelMessageAck:
		s := proto.Size(x.ChannelMessageAck)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelMessageSend:
		s := proto.Size(x.ChannelMessageSend)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelMessageUpdate:
		s := proto.Size(x.ChannelMessageUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelMessageRemove:
		s := proto.Size(x.ChannelMessageRemove)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_ChannelPresenceEvent:
		s := proto.Size(x.ChannelPresenceEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Error:
		s := proto.Size(x.Error)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Match:
		s := proto.Size(x.Match)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchCreate:
		s := proto.Size(x.MatchCreate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchData:
		s := proto.Size(x.MatchData)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchDataSend:
		s := proto.Size(x.MatchDataSend)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchJoin:
		s := proto.Size(x.MatchJoin)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchLeave:
		s := proto.Size(x.MatchLeave)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchPresenceEvent:
		s := proto.Size(x.MatchPresenceEvent)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchmakerAdd:
		s := proto.Size(x.MatchmakerAdd)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchmakerMatched:
		s := proto.Size(x.MatchmakerMatched)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchmakerRemove:
		s := proto.Size(x.MatchmakerRemove)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_MatchmakerTicket:
		s := proto.Size(x.MatchmakerTicket)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Notifications:
		s := proto.Size(x.Notifications)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Rpc:
		s := proto.Size(x.Rpc)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Status:
		s := proto.Size(x.Status)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StatusFollow:
		s := proto.Size(x.StatusFollow)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StatusPresenceEvent:
		s := proto.Size(x.StatusPresenceEvent)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StatusUnfollow:
		s := proto.Size(x.StatusUnfollow)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StatusUpdate:
		s := proto.Size(x.StatusUpdate)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StreamData:
		s := proto.Size(x.StreamData)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_StreamPresenceEvent:
		s := proto.Size(x.StreamPresenceEvent)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A realtime chat channel.
type Channel struct {
	// The ID of the channel.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The users currently in the channel.
	Presences []*UserPresence `protobuf:"bytes,2,rep,name=presences,proto3" json:"presences,omitempty"`
	// A reference to the current user's presence in the channel.
	Self                 *UserPresence `protobuf:"bytes,3,opt,name=self,proto3" json:"self,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}
func (*Channel) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{1}
}
func (m *Channel) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Channel.Unmarshal(m, b)
}
func (m *Channel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Channel.Marshal(b, m, deterministic)
}
func (dst *Channel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Channel.Merge(dst, src)
}
func (m *Channel) XXX_Size() int {
	return xxx_messageInfo_Channel.Size(m)
}
func (m *Channel) XXX_DiscardUnknown() {
	xxx_messageInfo_Channel.DiscardUnknown(m)
}

var xxx_messageInfo_Channel proto.InternalMessageInfo

func (m *Channel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Channel) GetPresences() []*UserPresence {
	if m != nil {
		return m.Presences
	}
	return nil
}

func (m *Channel) GetSelf() *UserPresence {
	if m != nil {
		return m.Self
	}
	return nil
}

// Join operation for a realtime chat channel.
type ChannelJoin struct {
	// The user ID to DM with, group ID to chat with, or room channel name to join.
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// The type of the chat channel.
	Type int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	// Whether messages sent on this channel should be persistent.
	Persistence *wrappers.BoolValue `protobuf:"bytes,3,opt,name=persistence,proto3" json:"persistence,omitempty"`
	// Whether the user should appear in the channel's presence list and events.
	Hidden               *wrappers.BoolValue `protobuf:"bytes,4,opt,name=hidden,proto3" json:"hidden,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ChannelJoin) Reset()         { *m = ChannelJoin{} }
func (m *ChannelJoin) String() string { return proto.CompactTextString(m) }
func (*ChannelJoin) ProtoMessage()    {}
func (*ChannelJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{2}
}
func (m *ChannelJoin) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelJoin.Unmarshal(m, b)
}
func (m *ChannelJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelJoin.Marshal(b, m, deterministic)
}
func (dst *ChannelJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelJoin.Merge(dst, src)
}
func (m *ChannelJoin) XXX_Size() int {
	return xxx_messageInfo_ChannelJoin.Size(m)
}
func (m *ChannelJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelJoin.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelJoin proto.InternalMessageInfo

func (m *ChannelJoin) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *ChannelJoin) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ChannelJoin) GetPersistence() *wrappers.BoolValue {
	if m != nil {
		return m.Persistence
	}
	return nil
}

func (m *ChannelJoin) GetHidden() *wrappers.BoolValue {
	if m != nil {
		return m.Hidden
	}
	return nil
}

// Leave a realtime channel.
type ChannelLeave struct {
	// The ID of the channel to leave.
	ChannelId            string   `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelLeave) Reset()         { *m = ChannelLeave{} }
func (m *ChannelLeave) String() string { return proto.CompactTextString(m) }
func (*ChannelLeave) ProtoMessage()    {}
func (*ChannelLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{3}
}
func (m *ChannelLeave) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelLeave.Unmarshal(m, b)
}
func (m *ChannelLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelLeave.Marshal(b, m, deterministic)
}
func (dst *ChannelLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelLeave.Merge(dst, src)
}
func (m *ChannelLeave) XXX_Size() int {
	return xxx_messageInfo_ChannelLeave.Size(m)
}
func (m *ChannelLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelLeave.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelLeave proto.InternalMessageInfo

func (m *ChannelLeave) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// A receipt reply from a channel message send operation.
type ChannelMessageAck struct {
	// The channel the message was sent to.
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// The unique ID assigned to the message.
	MessageId string `protobuf:"bytes,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// The code representing a message type or category.
	Code *wrappers.Int32Value `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	// Username of the message sender.
	Username string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	// The UNIX time when the message was created.
	CreateTime *timestamp.Timestamp `protobuf:"bytes,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// The UNIX time when the message was last updated.
	UpdateTime *timestamp.Timestamp `protobuf:"bytes,6,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// True if the message was persisted to the channel's history, false otherwise.
	Persistent           *wrappers.BoolValue `protobuf:"bytes,7,opt,name=persistent,proto3" json:"persistent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ChannelMessageAck) Reset()         { *m = ChannelMessageAck{} }
func (m *ChannelMessageAck) String() string { return proto.CompactTextString(m) }
func (*ChannelMessageAck) ProtoMessage()    {}
func (*ChannelMessageAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{4}
}
func (m *ChannelMessageAck) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelMessageAck.Unmarshal(m, b)
}
func (m *ChannelMessageAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelMessageAck.Marshal(b, m, deterministic)
}
func (dst *ChannelMessageAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMessageAck.Merge(dst, src)
}
func (m *ChannelMessageAck) XXX_Size() int {
	return xxx_messageInfo_ChannelMessageAck.Size(m)
}
func (m *ChannelMessageAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMessageAck.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMessageAck proto.InternalMessageInfo

func (m *ChannelMessageAck) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *ChannelMessageAck) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *ChannelMessageAck) GetCode() *wrappers.Int32Value {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *ChannelMessageAck) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ChannelMessageAck) GetCreateTime() *timestamp.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *ChannelMessageAck) GetUpdateTime() *timestamp.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *ChannelMessageAck) GetPersistent() *wrappers.BoolValue {
	if m != nil {
		return m.Persistent
	}
	return nil
}

// Send a message to a realtime channel.
type ChannelMessageSend struct {
	// The channel to sent to.
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// Message content.
	Content              string   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelMessageSend) Reset()         { *m = ChannelMessageSend{} }
func (m *ChannelMessageSend) String() string { return proto.CompactTextString(m) }
func (*ChannelMessageSend) ProtoMessage()    {}
func (*ChannelMessageSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{5}
}
func (m *ChannelMessageSend) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelMessageSend.Unmarshal(m, b)
}
func (m *ChannelMessageSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelMessageSend.Marshal(b, m, deterministic)
}
func (dst *ChannelMessageSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMessageSend.Merge(dst, src)
}
func (m *ChannelMessageSend) XXX_Size() int {
	return xxx_messageInfo_ChannelMessageSend.Size(m)
}
func (m *ChannelMessageSend) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMessageSend.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMessageSend proto.InternalMessageInfo

func (m *ChannelMessageSend) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *ChannelMessageSend) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// Update a message previously sent to a realtime channel.
type ChannelMessageUpdate struct {
	// The channel the message was sent to.
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// The ID assigned to the message to update.
	MessageId string `protobuf:"bytes,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// New message content.
	Content              string   `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelMessageUpdate) Reset()         { *m = ChannelMessageUpdate{} }
func (m *ChannelMessageUpdate) String() string { return proto.CompactTextString(m) }
func (*ChannelMessageUpdate) ProtoMessage()    {}
func (*ChannelMessageUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{6}
}
func (m *ChannelMessageUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelMessageUpdate.Unmarshal(m, b)
}
func (m *ChannelMessageUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelMessageUpdate.Marshal(b, m, deterministic)
}
func (dst *ChannelMessageUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMessageUpdate.Merge(dst, src)
}
func (m *ChannelMessageUpdate) XXX_Size() int {
	return xxx_messageInfo_ChannelMessageUpdate.Size(m)
}
func (m *ChannelMessageUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMessageUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMessageUpdate proto.InternalMessageInfo

func (m *ChannelMessageUpdate) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *ChannelMessageUpdate) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *ChannelMessageUpdate) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// Remove a message previously sent to a realtime channel.
type ChannelMessageRemove struct {
	// The channel the message was sent to.
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// The ID assigned to the message to update.
	MessageId            string   `protobuf:"bytes,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelMessageRemove) Reset()         { *m = ChannelMessageRemove{} }
func (m *ChannelMessageRemove) String() string { return proto.CompactTextString(m) }
func (*ChannelMessageRemove) ProtoMessage()    {}
func (*ChannelMessageRemove) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{7}
}
func (m *ChannelMessageRemove) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelMessageRemove.Unmarshal(m, b)
}
func (m *ChannelMessageRemove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelMessageRemove.Marshal(b, m, deterministic)
}
func (dst *ChannelMessageRemove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMessageRemove.Merge(dst, src)
}
func (m *ChannelMessageRemove) XXX_Size() int {
	return xxx_messageInfo_ChannelMessageRemove.Size(m)
}
func (m *ChannelMessageRemove) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMessageRemove.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMessageRemove proto.InternalMessageInfo

func (m *ChannelMessageRemove) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *ChannelMessageRemove) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

// A set of joins and leaves on a particular channel.
type ChannelPresenceEvent struct {
	// The channel identifier this event is for.
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// Presences joining the channel as part of this event, if any.
	Joins []*UserPresence `protobuf:"bytes,2,rep,name=joins,proto3" json:"joins,omitempty"`
	// Presences leaving the channel as part of this event, if any.
	Leaves               []*UserPresence `protobuf:"bytes,3,rep,name=leaves,proto3" json:"leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ChannelPresenceEvent) Reset()         { *m = ChannelPresenceEvent{} }
func (m *ChannelPresenceEvent) String() string { return proto.CompactTextString(m) }
func (*ChannelPresenceEvent) ProtoMessage()    {}
func (*ChannelPresenceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{8}
}
func (m *ChannelPresenceEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChannelPresenceEvent.Unmarshal(m, b)
}
func (m *ChannelPresenceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChannelPresenceEvent.Marshal(b, m, deterministic)
}
func (dst *ChannelPresenceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelPresenceEvent.Merge(dst, src)
}
func (m *ChannelPresenceEvent) XXX_Size() int {
	return xxx_messageInfo_ChannelPresenceEvent.Size(m)
}
func (m *ChannelPresenceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelPresenceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelPresenceEvent proto.InternalMessageInfo

func (m *ChannelPresenceEvent) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *ChannelPresenceEvent) GetJoins() []*UserPresence {
	if m != nil {
		return m.Joins
	}
	return nil
}

func (m *ChannelPresenceEvent) GetLeaves() []*UserPresence {
	if m != nil {
		return m.Leaves
	}
	return nil
}

// A logical error which may occur on the server.
type Error struct {
	// The error code which should be one of "Error.Code" enums.
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// A message in English to help developers debug the response.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Additional error details which may be different for each response.
	Context              map[string]string `protobuf:"bytes,3,rep,name=context,proto3" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{9}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Error.Unmarshal(m, b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Error.Marshal(b, m, deterministic)
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return xxx_messageInfo_Error.Size(m)
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetContext() map[string]string {
	if m != nil {
		return m.Context
	}
	return nil
}

// A realtime match.
type Match struct {
	// The match unique ID.
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	// True if it's an server-managed authoritative match, false otherwise.
	Authoritative bool `protobuf:"varint,2,opt,name=authoritative,proto3" json:"authoritative,omitempty"`
	// Match label, if any.
	Label *wrappers.StringValue `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
	// The number of users currently in the match.
	Size int32 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// The users currently in the match.
	Presences []*UserPresence `protobuf:"bytes,5,rep,name=presences,proto3" json:"presences,omitempty"`
	// A reference to the current user's presence in the match.
	Self                 *UserPresence `protobuf:"bytes,6,opt,name=self,proto3" json:"self,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Match) Reset()         { *m = Match{} }
func (m *Match) String() string { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()    {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{10}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Match.Unmarshal(m, b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Match.Marshal(b, m, deterministic)
}
func (dst *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(dst, src)
}
func (m *Match) XXX_Size() int {
	return xxx_messageInfo_Match.Size(m)
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *Match) GetAuthoritative() bool {
	if m != nil {
		return m.Authoritative
	}
	return false
}

func (m *Match) GetLabel() *wrappers.StringValue {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *Match) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Match) GetPresences() []*UserPresence {
	if m != nil {
		return m.Presences
	}
	return nil
}

func (m *Match) GetSelf() *UserPresence {
	if m != nil {
		return m.Self
	}
	return nil
}

// Create a new realtime match.
type MatchCreate struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchCreate) Reset()         { *m = MatchCreate{} }
func (m *MatchCreate) String() string { return proto.CompactTextString(m) }
func (*MatchCreate) ProtoMessage()    {}
func (*MatchCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{11}
}
func (m *MatchCreate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchCreate.Unmarshal(m, b)
}
func (m *MatchCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchCreate.Marshal(b, m, deterministic)
}
func (dst *MatchCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchCreate.Merge(dst, src)
}
func (m *MatchCreate) XXX_Size() int {
	return xxx_messageInfo_MatchCreate.Size(m)
}
func (m *MatchCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchCreate.DiscardUnknown(m)
}

var xxx_messageInfo_MatchCreate proto.InternalMessageInfo

// Realtime match data received from the server.
type MatchData struct {
	// The match unique ID.
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	// A reference to the user presence that sent this data, if any.
	Presence *UserPresence `protobuf:"bytes,2,opt,name=presence,proto3" json:"presence,omitempty"`
	// Op code value.
	OpCode int64 `protobuf:"varint,3,opt,name=op_code,json=opCode,proto3" json:"op_code,omitempty"`
	// Data payload, if any.
	Data                 []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchData) Reset()         { *m = MatchData{} }
func (m *MatchData) String() string { return proto.CompactTextString(m) }
func (*MatchData) ProtoMessage()    {}
func (*MatchData) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{12}
}
func (m *MatchData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchData.Unmarshal(m, b)
}
func (m *MatchData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchData.Marshal(b, m, deterministic)
}
func (dst *MatchData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchData.Merge(dst, src)
}
func (m *MatchData) XXX_Size() int {
	return xxx_messageInfo_MatchData.Size(m)
}
func (m *MatchData) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchData.DiscardUnknown(m)
}

var xxx_messageInfo_MatchData proto.InternalMessageInfo

func (m *MatchData) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *MatchData) GetPresence() *UserPresence {
	if m != nil {
		return m.Presence
	}
	return nil
}

func (m *MatchData) GetOpCode() int64 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *MatchData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Send realtime match data to the server.
type MatchDataSend struct {
	// The match unique ID.
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	// Op code value.
	OpCode int64 `protobuf:"varint,2,opt,name=op_code,json=opCode,proto3" json:"op_code,omitempty"`
	// Data payload, if any.
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// List of presences in the match to deliver to, if filtering is required. Otherwise deliver to everyone in the match.
	Presences            []*UserPresence `protobuf:"bytes,4,rep,name=presences,proto3" json:"presences,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchDataSend) Reset()         { *m = MatchDataSend{} }
func (m *MatchDataSend) String() string { return proto.CompactTextString(m) }
func (*MatchDataSend) ProtoMessage()    {}
func (*MatchDataSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{13}
}
func (m *MatchDataSend) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchDataSend.Unmarshal(m, b)
}
func (m *MatchDataSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchDataSend.Marshal(b, m, deterministic)
}
func (dst *MatchDataSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchDataSend.Merge(dst, src)
}
func (m *MatchDataSend) XXX_Size() int {
	return xxx_messageInfo_MatchDataSend.Size(m)
}
func (m *MatchDataSend) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchDataSend.DiscardUnknown(m)
}

var xxx_messageInfo_MatchDataSend proto.InternalMessageInfo

func (m *MatchDataSend) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *MatchDataSend) GetOpCode() int64 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *MatchDataSend) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MatchDataSend) GetPresences() []*UserPresence {
	if m != nil {
		return m.Presences
	}
	return nil
}

// Join an existing realtime match.
type MatchJoin struct {
	// Types that are valid to be assigned to Id:
	//	*MatchJoin_MatchId
	//	*MatchJoin_Token
	Id                   isMatchJoin_Id `protobuf_oneof:"id"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MatchJoin) Reset()         { *m = MatchJoin{} }
func (m *MatchJoin) String() string { return proto.CompactTextString(m) }
func (*MatchJoin) ProtoMessage()    {}
func (*MatchJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{14}
}
func (m *MatchJoin) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchJoin.Unmarshal(m, b)
}
func (m *MatchJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchJoin.Marshal(b, m, deterministic)
}
func (dst *MatchJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchJoin.Merge(dst, src)
}
func (m *MatchJoin) XXX_Size() int {
	return xxx_messageInfo_MatchJoin.Size(m)
}
func (m *MatchJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchJoin.DiscardUnknown(m)
}

var xxx_messageInfo_MatchJoin proto.InternalMessageInfo

type isMatchJoin_Id interface {
	isMatchJoin_Id()
}

type MatchJoin_MatchId struct {
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3,oneof"`
}
type MatchJoin_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

func (*MatchJoin_MatchId) isMatchJoin_Id() {}
func (*MatchJoin_Token) isMatchJoin_Id()   {}

func (m *MatchJoin) GetId() isMatchJoin_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MatchJoin) GetMatchId() string {
	if x, ok := m.GetId().(*MatchJoin_MatchId); ok {
		return x.MatchId
	}
	return ""
}

func (m *MatchJoin) GetToken() string {
	if x, ok := m.GetId().(*MatchJoin_Token); ok {
		return x.Token
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MatchJoin) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MatchJoin_OneofMarshaler, _MatchJoin_OneofUnmarshaler, _MatchJoin_OneofSizer, []interface{}{
		(*MatchJoin_MatchId)(nil),
		(*MatchJoin_Token)(nil),
	}
}

func _MatchJoin_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MatchJoin)
	// id
	switch x := m.Id.(type) {
	case *MatchJoin_MatchId:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.MatchId)
	case *MatchJoin_Token:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Token)
	case nil:
	default:
		return fmt.Errorf("MatchJoin.Id has unexpected type %T", x)
	}
	return nil
}

func _MatchJoin_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MatchJoin)
	switch tag {
	case 1: // id.match_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Id = &MatchJoin_MatchId{x}
		return true, err
	case 2: // id.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Id = &MatchJoin_Token{x}
		return true, err
	default:
		return false, nil
	}
}

func _MatchJoin_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MatchJoin)
	// id
	switch x := m.Id.(type) {
	case *MatchJoin_MatchId:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.MatchId)))
		n += len(x.MatchId)
	case *MatchJoin_Token:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Token)))
		n += len(x.Token)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Leave a realtime match.
type MatchLeave struct {
	// The match unique ID.
	MatchId              string   `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchLeave) Reset()         { *m = MatchLeave{} }
func (m *MatchLeave) String() string { return proto.CompactTextString(m) }
func (*MatchLeave) ProtoMessage()    {}
func (*MatchLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{15}
}
func (m *MatchLeave) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchLeave.Unmarshal(m, b)
}
func (m *MatchLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchLeave.Marshal(b, m, deterministic)
}
func (dst *MatchLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchLeave.Merge(dst, src)
}
func (m *MatchLeave) XXX_Size() int {
	return xxx_messageInfo_MatchLeave.Size(m)
}
func (m *MatchLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchLeave.DiscardUnknown(m)
}

var xxx_messageInfo_MatchLeave proto.InternalMessageInfo

func (m *MatchLeave) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

// A set of joins and leaves on a particular realtime match.
type MatchPresenceEvent struct {
	// The match unique ID.
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	// User presences that have just joined the match.
	Joins []*UserPresence `protobuf:"bytes,2,rep,name=joins,proto3" json:"joins,omitempty"`
	// User presences that have just left the match.
	Leaves               []*UserPresence `protobuf:"bytes,3,rep,name=leaves,proto3" json:"leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MatchPresenceEvent) Reset()         { *m = MatchPresenceEvent{} }
func (m *MatchPresenceEvent) String() string { return proto.CompactTextString(m) }
func (*MatchPresenceEvent) ProtoMessage()    {}
func (*MatchPresenceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{16}
}
func (m *MatchPresenceEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchPresenceEvent.Unmarshal(m, b)
}
func (m *MatchPresenceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchPresenceEvent.Marshal(b, m, deterministic)
}
func (dst *MatchPresenceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchPresenceEvent.Merge(dst, src)
}
func (m *MatchPresenceEvent) XXX_Size() int {
	return xxx_messageInfo_MatchPresenceEvent.Size(m)
}
func (m *MatchPresenceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchPresenceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MatchPresenceEvent proto.InternalMessageInfo

func (m *MatchPresenceEvent) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *MatchPresenceEvent) GetJoins() []*UserPresence {
	if m != nil {
		return m.Joins
	}
	return nil
}

func (m *MatchPresenceEvent) GetLeaves() []*UserPresence {
	if m != nil {
		return m.Leaves
	}
	return nil
}

// Start a new matchmaking process.
type MatchmakerAdd struct {
	// Minimum total user count to match together.
	MinCount int32 `protobuf:"varint,1,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty"`
	// Maximum total user count to match together.
	MaxCount int32 `protobuf:"varint,2,opt,name=max_count,json=maxCount,proto3" json:"max_count,omitempty"`
	// Filter query used to identify suitable users.
	Query string `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// String properties.
	StringProperties map[string]string `protobuf:"bytes,4,rep,name=string_properties,json=stringProperties,proto3" json:"string_properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Numeric properties.
	NumericProperties    map[string]float64 `protobuf:"bytes,5,rep,name=numeric_properties,json=numericProperties,proto3" json:"numeric_properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MatchmakerAdd) Reset()         { *m = MatchmakerAdd{} }
func (m *MatchmakerAdd) String() string { return proto.CompactTextString(m) }
func (*MatchmakerAdd) ProtoMessage()    {}
func (*MatchmakerAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{17}
}
func (m *MatchmakerAdd) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchmakerAdd.Unmarshal(m, b)
}
func (m *MatchmakerAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchmakerAdd.Marshal(b, m, deterministic)
}
func (dst *MatchmakerAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchmakerAdd.Merge(dst, src)
}
func (m *MatchmakerAdd) XXX_Size() int {
	return xxx_messageInfo_MatchmakerAdd.Size(m)
}
func (m *MatchmakerAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchmakerAdd.DiscardUnknown(m)
}

var xxx_messageInfo_MatchmakerAdd proto.InternalMessageInfo

func (m *MatchmakerAdd) GetMinCount() int32 {
	if m != nil {
		return m.MinCount
	}
	return 0
}

func (m *MatchmakerAdd) GetMaxCount() int32 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

func (m *MatchmakerAdd) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *MatchmakerAdd) GetStringProperties() map[string]string {
	if m != nil {
		return m.StringProperties
	}
	return nil
}

func (m *MatchmakerAdd) GetNumericProperties() map[string]float64 {
	if m != nil {
		return m.NumericProperties
	}
	return nil
}

// A successful matchmaking result.
type MatchmakerMatched struct {
	// The matchmaking ticket that has completed.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// The match token or match ID to join.
	//
	// Types that are valid to be assigned to Id:
	//	*MatchmakerMatched_MatchId
	//	*MatchmakerMatched_Token
	Id isMatchmakerMatched_Id `protobuf_oneof:"id"`
	// The users that have been matched together, and information about their matchmaking data.
	Users []*MatchmakerMatched_MatchmakerUser `protobuf:"bytes,4,rep,name=users,proto3" json:"users,omitempty"`
	// A reference to the current user and their properties.
	Self                 *MatchmakerMatched_MatchmakerUser `protobuf:"bytes,5,opt,name=self,proto3" json:"self,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *MatchmakerMatched) Reset()         { *m = MatchmakerMatched{} }
func (m *MatchmakerMatched) String() string { return proto.CompactTextString(m) }
func (*MatchmakerMatched) ProtoMessage()    {}
func (*MatchmakerMatched) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{18}
}
func (m *MatchmakerMatched) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchmakerMatched.Unmarshal(m, b)
}
func (m *MatchmakerMatched) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchmakerMatched.Marshal(b, m, deterministic)
}
func (dst *MatchmakerMatched) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchmakerMatched.Merge(dst, src)
}
func (m *MatchmakerMatched) XXX_Size() int {
	return xxx_messageInfo_MatchmakerMatched.Size(m)
}
func (m *MatchmakerMatched) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchmakerMatched.DiscardUnknown(m)
}

var xxx_messageInfo_MatchmakerMatched proto.InternalMessageInfo

type isMatchmakerMatched_Id interface {
	isMatchmakerMatched_Id()
}

type MatchmakerMatched_MatchId struct {
	MatchId string `protobuf:"bytes,2,opt,name=match_id,json=matchId,proto3,oneof"`
}
type MatchmakerMatched_Token struct {
	Token string `protobuf:"bytes,3,opt,name=token,proto3,oneof"`
}

func (*MatchmakerMatched_MatchId) isMatchmakerMatched_Id() {}
func (*MatchmakerMatched_Token) isMatchmakerMatched_Id()   {}

func (m *MatchmakerMatched) GetId() isMatchmakerMatched_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MatchmakerMatched) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

func (m *MatchmakerMatched) GetMatchId() string {
	if x, ok := m.GetId().(*MatchmakerMatched_MatchId); ok {
		return x.MatchId
	}
	return ""
}

func (m *MatchmakerMatched) GetToken() string {
	if x, ok := m.GetId().(*MatchmakerMatched_Token); ok {
		return x.Token
	}
	return ""
}

func (m *MatchmakerMatched) GetUsers() []*MatchmakerMatched_MatchmakerUser {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *MatchmakerMatched) GetSelf() *MatchmakerMatched_MatchmakerUser {
	if m != nil {
		return m.Self
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MatchmakerMatched) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MatchmakerMatched_OneofMarshaler, _MatchmakerMatched_OneofUnmarshaler, _MatchmakerMatched_OneofSizer, []interface{}{
		(*MatchmakerMatched_MatchId)(nil),
		(*MatchmakerMatched_Token)(nil),
	}
}

func _MatchmakerMatched_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MatchmakerMatched)
	// id
	switch x := m.Id.(type) {
	case *MatchmakerMatched_MatchId:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.MatchId)
	case *MatchmakerMatched_Token:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Token)
	case nil:
	default:
		return fmt.Errorf("MatchmakerMatched.Id has unexpected type %T", x)
	}
	return nil
}

func _MatchmakerMatched_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MatchmakerMatched)
	switch tag {
	case 2: // id.match_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Id = &MatchmakerMatched_MatchId{x}
		return true, err
	case 3: // id.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Id = &MatchmakerMatched_Token{x}
		return true, err
	default:
		return false, nil
	}
}

func _MatchmakerMatched_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MatchmakerMatched)
	// id
	switch x := m.Id.(type) {
	case *MatchmakerMatched_MatchId:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.MatchId)))
		n += len(x.MatchId)
	case *MatchmakerMatched_Token:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Token)))
		n += len(x.Token)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MatchmakerMatched_MatchmakerUser struct {
	// User info.
	Presence *UserPresence `protobuf:"bytes,1,opt,name=presence,proto3" json:"presence,omitempty"`
	// String properties.
	StringProperties map[string]string `protobuf:"bytes,5,rep,name=string_properties,json=stringProperties,proto3" json:"string_properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Numeric properties.
	NumericProperties    map[string]float64 `protobuf:"bytes,6,rep,name=numeric_properties,json=numericProperties,proto3" json:"numeric_properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MatchmakerMatched_MatchmakerUser) Reset()         { *m = MatchmakerMatched_MatchmakerUser{} }
func (m *MatchmakerMatched_MatchmakerUser) String() string { return proto.CompactTextString(m) }
func (*MatchmakerMatched_MatchmakerUser) ProtoMessage()    {}
func (*MatchmakerMatched_MatchmakerUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{18, 0}
}
func (m *MatchmakerMatched_MatchmakerUser) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchmakerMatched_MatchmakerUser.Unmarshal(m, b)
}
func (m *MatchmakerMatched_MatchmakerUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchmakerMatched_MatchmakerUser.Marshal(b, m, deterministic)
}
func (dst *MatchmakerMatched_MatchmakerUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchmakerMatched_MatchmakerUser.Merge(dst, src)
}
func (m *MatchmakerMatched_MatchmakerUser) XXX_Size() int {
	return xxx_messageInfo_MatchmakerMatched_MatchmakerUser.Size(m)
}
func (m *MatchmakerMatched_MatchmakerUser) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchmakerMatched_MatchmakerUser.DiscardUnknown(m)
}

var xxx_messageInfo_MatchmakerMatched_MatchmakerUser proto.InternalMessageInfo

func (m *MatchmakerMatched_MatchmakerUser) GetPresence() *UserPresence {
	if m != nil {
		return m.Presence
	}
	return nil
}

func (m *MatchmakerMatched_MatchmakerUser) GetStringProperties() map[string]string {
	if m != nil {
		return m.StringProperties
	}
	return nil
}

func (m *MatchmakerMatched_MatchmakerUser) GetNumericProperties() map[string]float64 {
	if m != nil {
		return m.NumericProperties
	}
	return nil
}

// Cancel an existing ongoing matchmaking process.
type MatchmakerRemove struct {
	// The ticket to cancel.
	Ticket               string   `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchmakerRemove) Reset()         { *m = MatchmakerRemove{} }
func (m *MatchmakerRemove) String() string { return proto.CompactTextString(m) }
func (*MatchmakerRemove) ProtoMessage()    {}
func (*MatchmakerRemove) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{19}
}
func (m *MatchmakerRemove) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchmakerRemove.Unmarshal(m, b)
}
func (m *MatchmakerRemove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchmakerRemove.Marshal(b, m, deterministic)
}
func (dst *MatchmakerRemove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchmakerRemove.Merge(dst, src)
}
func (m *MatchmakerRemove) XXX_Size() int {
	return xxx_messageInfo_MatchmakerRemove.Size(m)
}
func (m *MatchmakerRemove) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchmakerRemove.DiscardUnknown(m)
}

var xxx_messageInfo_MatchmakerRemove proto.InternalMessageInfo

func (m *MatchmakerRemove) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

// A ticket representing a new matchmaking process.
type MatchmakerTicket struct {
	// The ticket that can be used to cancel matchmaking.
	Ticket               string   `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MatchmakerTicket) Reset()         { *m = MatchmakerTicket{} }
func (m *MatchmakerTicket) String() string { return proto.CompactTextString(m) }
func (*MatchmakerTicket) ProtoMessage()    {}
func (*MatchmakerTicket) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{20}
}
func (m *MatchmakerTicket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchmakerTicket.Unmarshal(m, b)
}
func (m *MatchmakerTicket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchmakerTicket.Marshal(b, m, deterministic)
}
func (dst *MatchmakerTicket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchmakerTicket.Merge(dst, src)
}
func (m *MatchmakerTicket) XXX_Size() int {
	return xxx_messageInfo_MatchmakerTicket.Size(m)
}
func (m *MatchmakerTicket) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchmakerTicket.DiscardUnknown(m)
}

var xxx_messageInfo_MatchmakerTicket proto.InternalMessageInfo

func (m *MatchmakerTicket) GetTicket() string {
	if m != nil {
		return m.Ticket
	}
	return ""
}

// A collection of zero or more notifications.
type Notifications struct {
	// Collection of notifications.
	Notifications        []*api.Notification `protobuf:"bytes,1,rep,name=notifications,proto3" json:"notifications,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Notifications) Reset()         { *m = Notifications{} }
func (m *Notifications) String() string { return proto.CompactTextString(m) }
func (*Notifications) ProtoMessage()    {}
func (*Notifications) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{21}
}
func (m *Notifications) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Notifications.Unmarshal(m, b)
}
func (m *Notifications) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Notifications.Marshal(b, m, deterministic)
}
func (dst *Notifications) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notifications.Merge(dst, src)
}
func (m *Notifications) XXX_Size() int {
	return xxx_messageInfo_Notifications.Size(m)
}
func (m *Notifications) XXX_DiscardUnknown() {
	xxx_messageInfo_Notifications.DiscardUnknown(m)
}

var xxx_messageInfo_Notifications proto.InternalMessageInfo

func (m *Notifications) GetNotifications() []*api.Notification {
	if m != nil {
		return m.Notifications
	}
	return nil
}

// A snapshot of statuses for some set of users.
type Status struct {
	// User statuses.
	Presences            []*UserPresence `protobuf:"bytes,1,rep,name=presences,proto3" json:"presences,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{22}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Status.Unmarshal(m, b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Status.Marshal(b, m, deterministic)
}
func (dst *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(dst, src)
}
func (m *Status) XXX_Size() int {
	return xxx_messageInfo_Status.Size(m)
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetPresences() []*UserPresence {
	if m != nil {
		return m.Presences
	}
	return nil
}

// Start receiving status updates for some set of users.
type StatusFollow struct {
	// Users to follow.
	UserIds              []string `protobuf:"bytes,1,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusFollow) Reset()         { *m = StatusFollow{} }
func (m *StatusFollow) String() string { return proto.CompactTextString(m) }
func (*StatusFollow) ProtoMessage()    {}
func (*StatusFollow) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{23}
}
func (m *StatusFollow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StatusFollow.Unmarshal(m, b)
}
func (m *StatusFollow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StatusFollow.Marshal(b, m, deterministic)
}
func (dst *StatusFollow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusFollow.Merge(dst, src)
}
func (m *StatusFollow) XXX_Size() int {
	return xxx_messageInfo_StatusFollow.Size(m)
}
func (m *StatusFollow) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusFollow.DiscardUnknown(m)
}

var xxx_messageInfo_StatusFollow proto.InternalMessageInfo

func (m *StatusFollow) GetUserIds() []string {
	if m != nil {
		return m.UserIds
	}
	return nil
}

// A batch of status updates for a given user.
type StatusPresenceEvent struct {
	// New statuses for the user.
	Joins []*UserPresence `protobuf:"bytes,2,rep,name=joins,proto3" json:"joins,omitempty"`
	// Previous statuses for the user.
	Leaves               []*UserPresence `protobuf:"bytes,3,rep,name=leaves,proto3" json:"leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StatusPresenceEvent) Reset()         { *m = StatusPresenceEvent{} }
func (m *StatusPresenceEvent) String() string { return proto.CompactTextString(m) }
func (*StatusPresenceEvent) ProtoMessage()    {}
func (*StatusPresenceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{24}
}
func (m *StatusPresenceEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StatusPresenceEvent.Unmarshal(m, b)
}
func (m *StatusPresenceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StatusPresenceEvent.Marshal(b, m, deterministic)
}
func (dst *StatusPresenceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusPresenceEvent.Merge(dst, src)
}
func (m *StatusPresenceEvent) XXX_Size() int {
	return xxx_messageInfo_StatusPresenceEvent.Size(m)
}
func (m *StatusPresenceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusPresenceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_StatusPresenceEvent proto.InternalMessageInfo

func (m *StatusPresenceEvent) GetJoins() []*UserPresence {
	if m != nil {
		return m.Joins
	}
	return nil
}

func (m *StatusPresenceEvent) GetLeaves() []*UserPresence {
	if m != nil {
		return m.Leaves
	}
	return nil
}

// Stop receiving status updates for some set of users.
type StatusUnfollow struct {
	// Users to unfollow.
	UserIds              []string `protobuf:"bytes,1,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusUnfollow) Reset()         { *m = StatusUnfollow{} }
func (m *StatusUnfollow) String() string { return proto.CompactTextString(m) }
func (*StatusUnfollow) ProtoMessage()    {}
func (*StatusUnfollow) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{25}
}
func (m *StatusUnfollow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StatusUnfollow.Unmarshal(m, b)
}
func (m *StatusUnfollow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StatusUnfollow.Marshal(b, m, deterministic)
}
func (dst *StatusUnfollow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusUnfollow.Merge(dst, src)
}
func (m *StatusUnfollow) XXX_Size() int {
	return xxx_messageInfo_StatusUnfollow.Size(m)
}
func (m *StatusUnfollow) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusUnfollow.DiscardUnknown(m)
}

var xxx_messageInfo_StatusUnfollow proto.InternalMessageInfo

func (m *StatusUnfollow) GetUserIds() []string {
	if m != nil {
		return m.UserIds
	}
	return nil
}

// Set the user's own status.
type StatusUpdate struct {
	// Status string to set, if not present the user will appear offline.
	Status               *wrappers.StringValue `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StatusUpdate) Reset()         { *m = StatusUpdate{} }
func (m *StatusUpdate) String() string { return proto.CompactTextString(m) }
func (*StatusUpdate) ProtoMessage()    {}
func (*StatusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{26}
}
func (m *StatusUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StatusUpdate.Unmarshal(m, b)
}
func (m *StatusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StatusUpdate.Marshal(b, m, deterministic)
}
func (dst *StatusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusUpdate.Merge(dst, src)
}
func (m *StatusUpdate) XXX_Size() int {
	return xxx_messageInfo_StatusUpdate.Size(m)
}
func (m *StatusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_StatusUpdate proto.InternalMessageInfo

func (m *StatusUpdate) GetStatus() *wrappers.StringValue {
	if m != nil {
		return m.Status
	}
	return nil
}

// Represents identifying information for a stream.
type Stream struct {
	// Mode identifies the type of stream.
	Mode int32 `protobuf:"varint,1,opt,name=mode,proto3" json:"mode,omitempty"`
	// Subject is the primary identifier, if any.
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	// Descriptor is a secondary identifier, if any.
	Descriptor_ string `protobuf:"bytes,3,opt,name=descriptor,proto3" json:"descriptor,omitempty"`
	// The label is an arbitrary identifying string, if the stream has one.
	Label                string   `protobuf:"bytes,4,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{27}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Stream.Unmarshal(m, b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
}
func (dst *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(dst, src)
}
func (m *Stream) XXX_Size() int {
	return xxx_messageInfo_Stream.Size(m)
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *Stream) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Stream) GetDescriptor_() string {
	if m != nil {
		return m.Descriptor_
	}
	return ""
}

func (m *Stream) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// A data message delivered over a stream.
type StreamData struct {
	// The stream this data message relates to.
	Stream *Stream `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// The sender, if any.
	Sender *UserPresence `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// Arbitrary contents of the data message.
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamData) Reset()         { *m = StreamData{} }
func (m *StreamData) String() string { return proto.CompactTextString(m) }
func (*StreamData) ProtoMessage()    {}
func (*StreamData) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{28}
}
func (m *StreamData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamData.Unmarshal(m, b)
}
func (m *StreamData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamData.Marshal(b, m, deterministic)
}
func (dst *StreamData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamData.Merge(dst, src)
}
func (m *StreamData) XXX_Size() int {
	return xxx_messageInfo_StreamData.Size(m)
}
func (m *StreamData) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamData.DiscardUnknown(m)
}

var xxx_messageInfo_StreamData proto.InternalMessageInfo

func (m *StreamData) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

func (m *StreamData) GetSender() *UserPresence {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *StreamData) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// A set of joins and leaves on a particular stream.
type StreamPresenceEvent struct {
	// The stream this event relates to.
	Stream *Stream `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Presences joining the stream as part of this event, if any.
	Joins []*UserPresence `protobuf:"bytes,2,rep,name=joins,proto3" json:"joins,omitempty"`
	// Presences leaving the stream as part of this event, if any.
	Leaves               []*UserPresence `protobuf:"bytes,3,rep,name=leaves,proto3" json:"leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StreamPresenceEvent) Reset()         { *m = StreamPresenceEvent{} }
func (m *StreamPresenceEvent) String() string { return proto.CompactTextString(m) }
func (*StreamPresenceEvent) ProtoMessage()    {}
func (*StreamPresenceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{29}
}
func (m *StreamPresenceEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamPresenceEvent.Unmarshal(m, b)
}
func (m *StreamPresenceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamPresenceEvent.Marshal(b, m, deterministic)
}
func (dst *StreamPresenceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamPresenceEvent.Merge(dst, src)
}
func (m *StreamPresenceEvent) XXX_Size() int {
	return xxx_messageInfo_StreamPresenceEvent.Size(m)
}
func (m *StreamPresenceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamPresenceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_StreamPresenceEvent proto.InternalMessageInfo

func (m *StreamPresenceEvent) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

func (m *StreamPresenceEvent) GetJoins() []*UserPresence {
	if m != nil {
		return m.Joins
	}
	return nil
}

func (m *StreamPresenceEvent) GetLeaves() []*UserPresence {
	if m != nil {
		return m.Leaves
	}
	return nil
}

// A user session associated to a stream, usually through a list operation or a join/leave event.
type UserPresence struct {
	// The user this presence belongs to.
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// A unique session ID identifying the particular connection, because the user may have many.
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// The username for display purposes.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	// Whether this presence generates persistent data/messages, if applicable for the stream type.
	Persistence bool `protobuf:"varint,4,opt,name=persistence,proto3" json:"persistence,omitempty"`
	// A user-set status message for this stream, if applicable.
	Status               *wrappers.StringValue `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UserPresence) Reset()         { *m = UserPresence{} }
func (m *UserPresence) String() string { return proto.CompactTextString(m) }
func (*UserPresence) ProtoMessage()    {}
func (*UserPresence) Descriptor() ([]byte, []int) {
	return fileDescriptor_realtime_b2d08e58e86b33f6, []int{30}
}
func (m *UserPresence) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserPresence.Unmarshal(m, b)
}
func (m *UserPresence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserPresence.Marshal(b, m, deterministic)
}
func (dst *UserPresence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPresence.Merge(dst, src)
}
func (m *UserPresence) XXX_Size() int {
	return xxx_messageInfo_UserPresence.Size(m)
}
func (m *UserPresence) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPresence.DiscardUnknown(m)
}

var xxx_messageInfo_UserPresence proto.InternalMessageInfo

func (m *UserPresence) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *UserPresence) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *UserPresence) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserPresence) GetPersistence() bool {
	if m != nil {
		return m.Persistence
	}
	return false
}

func (m *UserPresence) GetStatus() *wrappers.StringValue {
	if m != nil {
		return m.Status
	}
	return nil
}

func init() {
	proto.RegisterType((*Envelope)(nil), "nakama.realtime.Envelope")
	proto.RegisterType((*Channel)(nil), "nakama.realtime.Channel")
	proto.RegisterType((*ChannelJoin)(nil), "nakama.realtime.ChannelJoin")
	proto.RegisterType((*ChannelLeave)(nil), "nakama.realtime.ChannelLeave")
	proto.RegisterType((*ChannelMessageAck)(nil), "nakama.realtime.ChannelMessageAck")
	proto.RegisterType((*ChannelMessageSend)(nil), "nakama.realtime.ChannelMessageSend")
	proto.RegisterType((*ChannelMessageUpdate)(nil), "nakama.realtime.ChannelMessageUpdate")
	proto.RegisterType((*ChannelMessageRemove)(nil), "nakama.realtime.ChannelMessageRemove")
	proto.RegisterType((*ChannelPresenceEvent)(nil), "nakama.realtime.ChannelPresenceEvent")
	proto.RegisterType((*Error)(nil), "nakama.realtime.Error")
	proto.RegisterMapType((map[string]string)(nil), "nakama.realtime.Error.ContextEntry")
	proto.RegisterType((*Match)(nil), "nakama.realtime.Match")
	proto.RegisterType((*MatchCreate)(nil), "nakama.realtime.MatchCreate")
	proto.RegisterType((*MatchData)(nil), "nakama.realtime.MatchData")
	proto.RegisterType((*MatchDataSend)(nil), "nakama.realtime.MatchDataSend")
	proto.RegisterType((*MatchJoin)(nil), "nakama.realtime.MatchJoin")
	proto.RegisterType((*MatchLeave)(nil), "nakama.realtime.MatchLeave")
	proto.RegisterType((*MatchPresenceEvent)(nil), "nakama.realtime.MatchPresenceEvent")
	proto.RegisterType((*MatchmakerAdd)(nil), "nakama.realtime.MatchmakerAdd")
	proto.RegisterMapType((map[string]float64)(nil), "nakama.realtime.MatchmakerAdd.NumericPropertiesEntry")
	proto.RegisterMapType((map[string]string)(nil), "nakama.realtime.MatchmakerAdd.StringPropertiesEntry")
	proto.RegisterType((*MatchmakerMatched)(nil), "nakama.realtime.MatchmakerMatched")
	proto.RegisterType((*MatchmakerMatched_MatchmakerUser)(nil), "nakama.realtime.MatchmakerMatched.MatchmakerUser")
	proto.RegisterMapType((map[string]float64)(nil), "nakama.realtime.MatchmakerMatched.MatchmakerUser.NumericPropertiesEntry")
	proto.RegisterMapType((map[string]string)(nil), "nakama.realtime.MatchmakerMatched.MatchmakerUser.StringPropertiesEntry")
	proto.RegisterType((*MatchmakerRemove)(nil), "nakama.realtime.MatchmakerRemove")
	proto.RegisterType((*MatchmakerTicket)(nil), "nakama.realtime.MatchmakerTicket")
	proto.RegisterType((*Notifications)(nil), "nakama.realtime.Notifications")
	proto.RegisterType((*Status)(nil), "nakama.realtime.Status")
	proto.RegisterType((*StatusFollow)(nil), "nakama.realtime.StatusFollow")
	proto.RegisterType((*StatusPresenceEvent)(nil), "nakama.realtime.StatusPresenceEvent")
	proto.RegisterType((*StatusUnfollow)(nil), "nakama.realtime.StatusUnfollow")
	proto.RegisterType((*StatusUpdate)(nil), "nakama.realtime.StatusUpdate")
	proto.RegisterType((*Stream)(nil), "nakama.realtime.Stream")
	proto.RegisterType((*StreamData)(nil), "nakama.realtime.StreamData")
	proto.RegisterType((*StreamPresenceEvent)(nil), "nakama.realtime.StreamPresenceEvent")
	proto.RegisterType((*UserPresence)(nil), "nakama.realtime.UserPresence")
	proto.RegisterEnum("nakama.realtime.ChannelJoin_Type", ChannelJoin_Type_name, ChannelJoin_Type_value)
	proto.RegisterEnum("nakama.realtime.Error_Code", Error_Code_name, Error_Code_value)
}

func init() { proto.RegisterFile("rtapi/realtime.proto", fileDescriptor_realtime_b2d08e58e86b33f6) }

var fileDescriptor_realtime_b2d08e58e86b33f6 = []byte{
	// 2128 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcf, 0x73, 0xe3, 0x48,
	0xf5, 0xb7, 0x6c, 0xcb, 0x89, 0x5f, 0x7e, 0x39, 0x1d, 0x27, 0xd1, 0x3a, 0x3b, 0x99, 0xf9, 0x6a,
	0xf6, 0x5b, 0x2c, 0x4b, 0xe1, 0xd4, 0xfc, 0xd8, 0x2a, 0x98, 0x85, 0x29, 0x12, 0x5b, 0x89, 0x3d,
	0x6c, 0x6c, 0x97, 0x6c, 0xb3, 0xec, 0x54, 0x51, 0x2a, 0x45, 0xea, 0x49, 0xb4, 0xb1, 0x24, 0x23,
	0xc9, 0x99, 0x09, 0x27, 0xb8, 0xc1, 0x85, 0x13, 0x37, 0x4e, 0x70, 0x84, 0x1b, 0xdc, 0x38, 0x70,
	0xe3, 0xc0, 0x9d, 0xbf, 0x84, 0x33, 0x07, 0xaa, 0x7f, 0x48, 0x96, 0x64, 0xcb, 0x4e, 0x76, 0xab,
	0xa6, 0x8a, 0x53, 0xdc, 0xaf, 0x3f, 0xef, 0xf3, 0x5a, 0xaf, 0x5f, 0xbf, 0x7e, 0xaf, 0x03, 0x55,
	0x2f, 0xd0, 0xc7, 0xd6, 0x91, 0x87, 0xf5, 0x51, 0x60, 0xd9, 0xb8, 0x3e, 0xf6, 0xdc, 0xc0, 0x45,
	0x5b, 0x8e, 0x7e, 0xad, 0xdb, 0x7a, 0x3d, 0x14, 0xd7, 0x1e, 0x5e, 0xba, 0xee, 0xe5, 0x08, 0x1f,
	0xd1, 0xe9, 0x8b, 0xc9, 0x9b, 0x23, 0x22, 0xf5, 0x03, 0xdd, 0x1e, 0x33, 0x8d, 0xda, 0x61, 0x1a,
	0xf0, 0xd6, 0xd3, 0xc7, 0x63, 0xec, 0xf9, 0x7c, 0xfe, 0x93, 0x4b, 0x2b, 0xb8, 0x9a, 0x5c, 0xd4,
	0x0d, 0xd7, 0x3e, 0xba, 0xc2, 0x9e, 0x6b, 0x19, 0x23, 0xfd, 0xc2, 0x3f, 0x62, 0x76, 0x8e, 0xc8,
	0x12, 0xf4, 0xb1, 0xc5, 0xb0, 0xf2, 0x9f, 0xb7, 0x61, 0x55, 0x71, 0x6e, 0xf0, 0xc8, 0x1d, 0x63,
	0x54, 0x81, 0x82, 0x61, 0x99, 0x92, 0xf0, 0x48, 0xf8, 0xb8, 0xac, 0x92, 0x9f, 0xe8, 0x39, 0xac,
	0x18, 0x57, 0xba, 0xe3, 0xe0, 0x91, 0x94, 0x7f, 0x24, 0x7c, 0xbc, 0xf6, 0x54, 0xaa, 0xa7, 0x96,
	0x5b, 0x6f, 0xb0, 0xf9, 0x56, 0x4e, 0x0d, 0xa1, 0xe8, 0x18, 0xd6, 0xf9, 0x4f, 0xed, 0x2b, 0xd7,
	0x72, 0xa4, 0x02, 0x55, 0xfd, 0x30, 0x4b, 0xf5, 0x95, 0x6b, 0x39, 0xad, 0x9c, 0xba, 0x66, 0x4c,
	0x87, 0xa8, 0x09, 0x1b, 0x21, 0xc5, 0x08, 0xeb, 0x37, 0x58, 0x2a, 0x52, 0x8e, 0x07, 0x59, 0x1c,
	0x9f, 0x13, 0x50, 0x2b, 0xa7, 0x86, 0x86, 0xe9, 0x18, 0x29, 0xb0, 0x15, 0xb2, 0xd8, 0xd8, 0xf7,
	0xf5, 0x4b, 0x2c, 0x89, 0x94, 0xa7, 0x16, 0xf2, 0x10, 0x4f, 0x70, 0x8a, 0x73, 0x86, 0x68, 0xe5,
	0xd4, 0x4d, 0x23, 0x21, 0x41, 0x03, 0xd8, 0x49, 0xd1, 0x68, 0xba, 0x71, 0x2d, 0x95, 0x28, 0x95,
	0x9c, 0xb5, 0x24, 0xae, 0x7d, 0x6c, 0x5c, 0xb7, 0x72, 0xea, 0xb6, 0x91, 0x16, 0xa2, 0x2f, 0xa0,
	0x9a, 0x66, 0xf5, 0xb1, 0x63, 0x4a, 0x2b, 0x94, 0xf6, 0xf1, 0x12, 0xda, 0x3e, 0x76, 0xcc, 0x56,
	0x4e, 0x45, 0xc6, 0x8c, 0x14, 0xfd, 0x0c, 0xf6, 0xd2, 0xc4, 0x93, 0xb1, 0xa9, 0x07, 0x58, 0x5a,
	0xa5, 0xd4, 0xff, 0xbf, 0x84, 0x7a, 0x48, 0xc1, 0xad, 0x9c, 0x5a, 0x35, 0xe6, 0xc8, 0xe7, 0xd1,
	0x7b, 0xd8, 0x76, 0x6f, 0xb0, 0x54, 0xbe, 0x13, 0xbd, 0x4a, 0xc1, 0xb3, 0xf4, 0x4c, 0x1e, 0xa7,
	0x1f, 0x7b, 0xd8, 0xc7, 0x8e, 0x81, 0x35, 0x7c, 0x83, 0x9d, 0x40, 0x82, 0xc5, 0xf4, 0x3d, 0x8e,
	0x56, 0x08, 0x38, 0x46, 0x9f, 0x90, 0xa3, 0x3a, 0x88, 0xd8, 0xf3, 0x5c, 0x4f, 0x5a, 0xa3, 0x6c,
	0x7b, 0x33, 0x6c, 0x0a, 0x99, 0x6d, 0xe5, 0x54, 0x06, 0x23, 0x78, 0x5b, 0x0f, 0x8c, 0x2b, 0x69,
	0x3d, 0x03, 0x7f, 0x4e, 0x66, 0x09, 0x9e, 0xc2, 0x48, 0xec, 0xd3, 0x1f, 0x9a, 0xe1, 0x61, 0xe2,
	0xf2, 0x8d, 0x8c, 0xd8, 0xa7, 0x6a, 0x0d, 0x8a, 0x21, 0xb1, 0x6f, 0x4f, 0x87, 0xe8, 0x33, 0x00,
	0x46, 0x61, 0xea, 0x81, 0x2e, 0x6d, 0x26, 0x03, 0x36, 0x49, 0xd0, 0xd4, 0x03, 0xbd, 0x95, 0x53,
	0xcb, 0x76, 0x38, 0x40, 0x2d, 0xd8, 0x9a, 0x2a, 0xb3, 0x80, 0xda, 0xa2, 0x0c, 0x87, 0xd9, 0x0c,
	0x3c, 0x96, 0x36, 0xec, 0xb8, 0x60, 0xba, 0x0c, 0x7a, 0x86, 0x2b, 0x8b, 0x96, 0xc1, 0x4f, 0x30,
	0x5b, 0x06, 0x3d, 0xbf, 0x2f, 0x81, 0x7d, 0x12, 0x3f, 0xbd, 0xdb, 0x54, 0xfb, 0x60, 0xbe, 0x76,
	0x78, 0x76, 0x99, 0x39, 0x76, 0x72, 0xbf, 0x80, 0x2a, 0xd3, 0x4f, 0xc5, 0x00, 0xca, 0x38, 0x1c,
	0x94, 0x28, 0x1d, 0x01, 0xc8, 0x9e, 0x91, 0xa2, 0x33, 0xd8, 0xa4, 0x52, 0x5b, 0xbf, 0xc6, 0x9e,
	0xa6, 0x9b, 0xa6, 0xb4, 0xb3, 0xc8, 0x3d, 0x14, 0x76, 0x6c, 0x4e, 0xdd, 0x13, 0x0a, 0x50, 0x1f,
	0x50, 0x8c, 0x88, 0xfe, 0xc4, 0xa6, 0x54, 0xcd, 0xc8, 0x09, 0x53, 0xb2, 0x73, 0x86, 0x24, 0x39,
	0xc1, 0x4e, 0x0b, 0x51, 0x0f, 0x62, 0xc2, 0xf0, 0x58, 0xed, 0x52, 0xce, 0xff, 0x5b, 0xc0, 0x19,
	0x1d, 0xa9, 0x8a, 0x9d, 0x92, 0xa5, 0x18, 0x03, 0xcb, 0xb8, 0xc6, 0x81, 0xb4, 0xb7, 0x94, 0x71,
	0x40, 0x81, 0x49, 0x46, 0x26, 0x43, 0xa7, 0xb0, 0xe1, 0xb8, 0x81, 0xf5, 0xc6, 0x32, 0xf4, 0xc0,
	0x72, 0x1d, 0x5f, 0xda, 0xcf, 0x70, 0x60, 0x27, 0x8e, 0x22, 0x0e, 0x4c, 0xa8, 0xa1, 0xc7, 0x50,
	0xf0, 0xc6, 0x86, 0x24, 0x51, 0xed, 0xad, 0x78, 0x42, 0x56, 0xc7, 0x46, 0x2b, 0xa7, 0x92, 0x59,
	0xf4, 0x04, 0x4a, 0x7e, 0xa0, 0x07, 0x13, 0x5f, 0xfa, 0x80, 0xe2, 0xf6, 0x67, 0xac, 0xf4, 0xe9,
	0x74, 0x2b, 0xa7, 0x72, 0x20, 0xb9, 0x3a, 0xd8, 0x2f, 0xed, 0x8d, 0x3b, 0x1a, 0xb9, 0x6f, 0xa5,
	0x5a, 0xc6, 0xd5, 0xc1, 0x34, 0x4f, 0x29, 0x88, 0x5c, 0x1d, 0x7e, 0x6c, 0x8c, 0x5e, 0xc3, 0x2e,
	0x67, 0x49, 0x45, 0xe0, 0x01, 0x65, 0xfb, 0x28, 0x83, 0x2d, 0x1d, 0x82, 0x3b, 0xfe, 0xac, 0x18,
	0xbd, 0x82, 0x2d, 0xce, 0x3d, 0x71, 0xf8, 0x1a, 0x3f, 0xa4, 0xac, 0x0f, 0x33, 0x58, 0x87, 0x1c,
	0x46, 0xee, 0x26, 0x3f, 0x21, 0x89, 0x7d, 0x2d, 0xcf, 0xf1, 0x0f, 0x16, 0x7e, 0x6d, 0x94, 0xdb,
	0xf9, 0xd7, 0xf2, 0x9c, 0xfe, 0x12, 0xd6, 0xfc, 0xc0, 0xc3, 0xba, 0xcd, 0x72, 0xce, 0x61, 0xc6,
	0x71, 0xed, 0x53, 0x0c, 0x4f, 0x3a, 0xe0, 0x47, 0x23, 0xe6, 0x2d, 0xaa, 0x9f, 0xf2, 0xd6, 0xc3,
	0x4c, 0x6f, 0x11, 0xf4, 0x1c, 0x6f, 0xcd, 0x88, 0x4f, 0xca, 0xb0, 0xc2, 0xef, 0x19, 0xf9, 0x37,
	0x02, 0xac, 0xf0, 0x6c, 0x8f, 0x36, 0x21, 0x1f, 0xd5, 0x2a, 0x79, 0x8b, 0xa4, 0xab, 0x72, 0x68,
	0xdb, 0x97, 0xf2, 0x8f, 0x0a, 0x73, 0x9d, 0x30, 0xf4, 0xb1, 0x17, 0xb2, 0xab, 0x53, 0x3c, 0x7a,
	0x02, 0x45, 0x1f, 0x8f, 0xde, 0xf0, 0x4a, 0x65, 0x89, 0x1e, 0x85, 0xca, 0xff, 0x16, 0x60, 0x2d,
	0x56, 0xc0, 0xa0, 0x3d, 0x28, 0x05, 0xba, 0x77, 0x89, 0x03, 0xbe, 0x26, 0x3e, 0x42, 0x08, 0x8a,
	0xc1, 0xed, 0x18, 0xd3, 0xfa, 0x49, 0x54, 0xe9, 0x6f, 0xf4, 0x03, 0x58, 0x23, 0xf5, 0x9a, 0xe5,
	0x07, 0x84, 0x90, 0x5b, 0xad, 0xd5, 0x59, 0x5d, 0x57, 0x0f, 0xeb, 0xba, 0xfa, 0x89, 0xeb, 0x8e,
	0x7e, 0xa2, 0x8f, 0x26, 0x58, 0x8d, 0xc3, 0xd1, 0x53, 0x28, 0x5d, 0x59, 0xa6, 0x89, 0x1d, 0x5e,
	0x14, 0x2d, 0x52, 0xe4, 0x48, 0x59, 0x81, 0xe2, 0x80, 0x58, 0xae, 0x42, 0x65, 0xf0, 0x65, 0x4f,
	0xd1, 0x86, 0x9d, 0x7e, 0x4f, 0x69, 0xb4, 0x4f, 0xdb, 0x4a, 0xb3, 0x92, 0x43, 0xab, 0x50, 0x54,
	0xbb, 0xdd, 0xf3, 0x8a, 0x80, 0x10, 0x6c, 0x36, 0xdb, 0xaa, 0xd2, 0x18, 0x68, 0xe7, 0x4a, 0xbf,
	0x7f, 0x7c, 0xa6, 0x54, 0xf2, 0xa8, 0x0c, 0xe2, 0x99, 0xda, 0x1d, 0xf6, 0x2a, 0x05, 0xf9, 0xbb,
	0xb0, 0x1e, 0x2f, 0xb8, 0xd0, 0x03, 0x80, 0xf0, 0xb2, 0x8e, 0x36, 0xa3, 0xcc, 0x25, 0x6d, 0x53,
	0xfe, 0x57, 0x1e, 0xb6, 0x67, 0xaa, 0xa1, 0x25, 0x4a, 0x64, 0x3a, 0xac, 0x2b, 0x2c, 0x93, 0xba,
	0xad, 0xac, 0x96, 0xb9, 0xa4, 0x6d, 0xa2, 0x23, 0x28, 0x1a, 0xae, 0x19, 0x3a, 0xed, 0x60, 0xe6,
	0xdb, 0xdb, 0x4e, 0xf0, 0xec, 0x29, 0xfb, 0x78, 0x0a, 0x44, 0x35, 0x58, 0x9d, 0xf8, 0xd8, 0x73,
	0x74, 0x9b, 0x55, 0x91, 0x65, 0x35, 0x1a, 0xa3, 0xcf, 0x60, 0x8d, 0xdd, 0xd3, 0x1a, 0xd9, 0xe6,
	0xa8, 0x38, 0x4c, 0x73, 0x0e, 0xc2, 0x0a, 0x5c, 0x05, 0x06, 0x27, 0x02, 0xa2, 0xcc, 0xce, 0x1c,
	0x53, 0x2e, 0x2d, 0x57, 0x66, 0x70, 0xaa, 0xfc, 0x02, 0x20, 0xda, 0xd3, 0x80, 0xd7, 0x7c, 0x8b,
	0x36, 0x32, 0x86, 0x96, 0xcf, 0x01, 0xcd, 0x16, 0x83, 0xcb, 0xdc, 0x2a, 0xc1, 0x8a, 0xe1, 0x3a,
	0xd4, 0x1a, 0xf3, 0x69, 0x38, 0x94, 0x1d, 0xa8, 0xce, 0x2b, 0x00, 0xbf, 0xe1, 0x3e, 0xc5, 0xec,
	0x15, 0x92, 0xf6, 0x06, 0x69, 0x7b, 0xfc, 0xaa, 0xfa, 0x46, 0xf6, 0xe4, 0x3f, 0x08, 0x11, 0x6d,
	0x32, 0xdb, 0x2e, 0xa1, 0x7d, 0x06, 0x22, 0x29, 0x70, 0xee, 0x98, 0x33, 0x18, 0x16, 0x7d, 0x0a,
	0x25, 0x5a, 0xd8, 0xf8, 0x52, 0xe1, 0x2e, 0x5a, 0x1c, 0x2c, 0xff, 0x27, 0x0f, 0x22, 0xad, 0x2f,
	0x49, 0x56, 0xa0, 0x51, 0x2c, 0xb0, 0xac, 0x40, 0x03, 0x55, 0x8a, 0x12, 0x5d, 0xb8, 0x43, 0x7c,
	0x88, 0x7e, 0xc8, 0x7d, 0xf9, 0x2e, 0xe0, 0xf6, 0x1e, 0xcf, 0x2f, 0x5b, 0xeb, 0x0d, 0x86, 0x52,
	0x9c, 0xc0, 0xbb, 0x55, 0x43, 0x9d, 0xda, 0x0b, 0x58, 0x8f, 0x4f, 0x90, 0x3e, 0xef, 0x1a, 0xdf,
	0x86, 0x7d, 0xde, 0x35, 0xbe, 0x45, 0x55, 0x10, 0x6f, 0x48, 0x98, 0x71, 0xc3, 0x6c, 0xf0, 0x22,
	0xff, 0x3d, 0x41, 0xfe, 0xa7, 0x00, 0xc5, 0x06, 0x59, 0xdd, 0x2e, 0x6c, 0xab, 0xc3, 0xce, 0xa0,
	0x7d, 0xae, 0x68, 0xca, 0x4f, 0x1b, 0x4a, 0x6f, 0xd0, 0xee, 0x76, 0x2a, 0x39, 0x24, 0x41, 0x75,
	0xd8, 0x51, 0x95, 0x46, 0xf7, 0xac, 0xd3, 0x7e, 0xad, 0x34, 0xb5, 0xde, 0xf1, 0x97, 0x9f, 0x77,
	0x8f, 0x9b, 0x15, 0x01, 0xed, 0xc0, 0xd6, 0x79, 0xbb, 0xdf, 0x6f, 0x77, 0xce, 0x22, 0x61, 0x1e,
	0x6d, 0x40, 0xf9, 0xe4, 0xb8, 0xa9, 0xb5, 0x3b, 0xbd, 0xe1, 0xa0, 0x52, 0xa0, 0x98, 0xe3, 0x41,
	0xa3, 0xa5, 0x75, 0xba, 0x03, 0xed, 0xb4, 0x3b, 0xec, 0x34, 0x2b, 0x45, 0xb4, 0x0f, 0x3b, 0x4c,
	0xf8, 0xaa, 0xdb, 0xee, 0x68, 0xaa, 0xf2, 0x4a, 0x69, 0x0c, 0x94, 0x66, 0x45, 0x44, 0x87, 0x50,
	0x0b, 0x97, 0x70, 0x3a, 0xec, 0x34, 0xc8, 0x0a, 0x62, 0x8a, 0xa5, 0xb9, 0xf3, 0xd3, 0xb5, 0xae,
	0xc8, 0xbf, 0xcc, 0x83, 0x48, 0x4b, 0x1c, 0xf4, 0x01, 0xac, 0xb2, 0xf2, 0x32, 0x8a, 0x88, 0x15,
	0x3a, 0x6e, 0x9b, 0xe8, 0x23, 0xd8, 0xd0, 0x27, 0xc1, 0x95, 0xeb, 0x59, 0x81, 0x1e, 0x58, 0x37,
	0xcc, 0x25, 0xab, 0x6a, 0x52, 0x88, 0x9e, 0x82, 0x38, 0xd2, 0x2f, 0xf0, 0x28, 0xea, 0x6d, 0xd3,
	0x27, 0xb7, 0x1f, 0x78, 0x96, 0x73, 0xc9, 0xce, 0x2e, 0x83, 0x92, 0x3d, 0xf7, 0xad, 0x5f, 0xb0,
	0x24, 0x24, 0xaa, 0xf4, 0x77, 0xf2, 0xd6, 0x12, 0xbf, 0xe6, 0xad, 0x55, 0xba, 0xfb, 0xad, 0xb5,
	0x01, 0x6b, 0xb1, 0xce, 0x43, 0xfe, 0xad, 0x00, 0xe5, 0xa8, 0x0d, 0x58, 0xe4, 0x95, 0xef, 0xc3,
	0x6a, 0x68, 0x97, 0xbf, 0x04, 0x2c, 0x31, 0x17, 0xc1, 0xd1, 0x3e, 0xac, 0xb8, 0x63, 0x2d, 0xca,
	0xd9, 0x05, 0xb5, 0xe4, 0x8e, 0x69, 0x44, 0x21, 0x28, 0xd2, 0x6a, 0x83, 0xf8, 0x63, 0x5d, 0xa5,
	0xbf, 0xe5, 0xdf, 0x09, 0xb0, 0x91, 0xe8, 0x4b, 0x16, 0x2d, 0x2a, 0xc6, 0x9c, 0x9f, 0xcb, 0x5c,
	0x98, 0x32, 0x27, 0x3d, 0x5d, 0xbc, 0x9f, 0xa7, 0xe5, 0x53, 0xee, 0x26, 0x7a, 0xd3, 0x1f, 0xa4,
	0x57, 0xd4, 0xca, 0x4d, 0xd7, 0xb4, 0x07, 0x62, 0xe0, 0x5e, 0x63, 0x87, 0x9d, 0x24, 0xd2, 0x17,
	0xd2, 0xe1, 0x49, 0x91, 0x94, 0x2b, 0xf2, 0xb7, 0x00, 0xa6, 0x2d, 0xcf, 0x82, 0x4f, 0x93, 0x7f,
	0x2f, 0x00, 0x9a, 0xed, 0x69, 0x16, 0x39, 0xe3, 0x7d, 0xe6, 0xb1, 0xbf, 0x16, 0xf8, 0x2e, 0x45,
	0xdd, 0xd0, 0x01, 0x94, 0x6d, 0xcb, 0xd1, 0x0c, 0x77, 0xe2, 0x04, 0x3c, 0xa9, 0xad, 0xda, 0x96,
	0xd3, 0x20, 0x63, 0x3a, 0xa9, 0xbf, 0xe3, 0x93, 0x79, 0x3e, 0xa9, 0xbf, 0x63, 0x93, 0x55, 0x10,
	0x7f, 0x3e, 0xc1, 0xde, 0x2d, 0xbf, 0x25, 0xd8, 0x00, 0xe9, 0xb0, 0xed, 0xd3, 0x13, 0xa4, 0x8d,
	0x3d, 0x77, 0x8c, 0xbd, 0xc0, 0x8a, 0x76, 0xed, 0xf9, 0xe2, 0x4e, 0x8d, 0x9f, 0xbc, 0x5e, 0xa4,
	0xc6, 0x92, 0x61, 0xc5, 0x4f, 0x89, 0x91, 0x09, 0xc8, 0x99, 0xd8, 0xd8, 0xb3, 0x8c, 0xb8, 0x0d,
	0x76, 0x06, 0x3f, 0x5d, 0x62, 0xa3, 0xc3, 0x14, 0xd3, 0x46, 0xb6, 0x9d, 0xb4, 0xbc, 0xd6, 0x80,
	0xdd, 0xb9, 0x0b, 0xba, 0x4f, 0x12, 0xae, 0x35, 0x61, 0x6f, 0xbe, 0xc5, 0x65, 0x2c, 0x42, 0x3c,
	0x95, 0xff, 0x5d, 0x84, 0xed, 0x99, 0x3e, 0x94, 0xd6, 0xad, 0xac, 0x2b, 0x0c, 0xeb, 0x56, 0xd6,
	0xe6, 0xc5, 0xa3, 0x3c, 0x9f, 0x19, 0xe5, 0x85, 0x44, 0x94, 0xa3, 0x33, 0x10, 0x49, 0x6d, 0x15,
	0x6e, 0xd5, 0x93, 0xe5, 0x7d, 0x70, 0x4c, 0x42, 0x42, 0x4d, 0x65, 0xfa, 0x48, 0xe1, 0xa9, 0x8d,
	0x55, 0x64, 0x5f, 0x83, 0x87, 0xaa, 0xd7, 0xfe, 0x51, 0x80, 0xcd, 0xe4, 0x44, 0x22, 0x93, 0x09,
	0xf7, 0xcb, 0x64, 0xc1, 0xbc, 0xa0, 0x64, 0x01, 0x73, 0x76, 0xef, 0x15, 0xde, 0x39, 0x4e, 0xdf,
	0xce, 0x8d, 0xd3, 0x12, 0x35, 0xdb, 0xba, 0xbf, 0xd9, 0xff, 0xc5, 0xd0, 0xe5, 0xd9, 0xf3, 0x13,
	0xa8, 0xa4, 0xdf, 0x3c, 0xb2, 0xc2, 0x37, 0x89, 0xe5, 0x2f, 0x17, 0x59, 0xd8, 0x2e, 0x6c, 0x24,
	0xde, 0x2a, 0xd0, 0xcb, 0xf4, 0x13, 0x87, 0x40, 0xbd, 0x2d, 0xc5, 0x1f, 0x29, 0xe2, 0x1a, 0xa9,
	0xa7, 0x0d, 0x59, 0x81, 0x12, 0x6b, 0xb7, 0x93, 0xb7, 0x8e, 0x70, 0xcf, 0x5b, 0xe7, 0xdb, 0xb0,
	0x1e, 0x7f, 0xa3, 0x20, 0xd9, 0x9f, 0x9c, 0x0e, 0xcd, 0x32, 0x19, 0x57, 0x59, 0x5d, 0x21, 0xe3,
	0xb6, 0xe9, 0xcb, 0xbf, 0x12, 0x60, 0x67, 0xce, 0x0b, 0xc4, 0x7b, 0xbd, 0x15, 0xbe, 0x03, 0x9b,
	0xc9, 0xe7, 0x8a, 0x45, 0x0b, 0x6e, 0x86, 0xdf, 0xc6, 0x9b, 0x8d, 0xe7, 0xd1, 0x43, 0x8f, 0x70,
	0x87, 0x8a, 0x8a, 0x63, 0xe5, 0x11, 0x71, 0xb4, 0x87, 0x75, 0x9b, 0x5c, 0xf9, 0x76, 0xac, 0xa0,
	0xb6, 0x79, 0x41, 0xed, 0x4f, 0x2e, 0xbe, 0xc2, 0x46, 0xd4, 0xf2, 0xf0, 0x21, 0x3a, 0x04, 0x30,
	0xb1, 0x6f, 0x78, 0xd6, 0x38, 0x70, 0x3d, 0x7e, 0xf3, 0xc4, 0x24, 0x24, 0x12, 0x59, 0x79, 0xc7,
	0x1a, 0x46, 0x36, 0x90, 0x7f, 0x2d, 0x00, 0x4c, 0x9f, 0x40, 0xd0, 0x11, 0x59, 0x32, 0x19, 0xf1,
	0x25, 0xef, 0x67, 0xbc, 0x72, 0xa8, 0x1c, 0x46, 0xfc, 0xea, 0x63, 0xc7, 0xc4, 0xde, 0xdd, 0x4a,
	0x28, 0x0e, 0x4e, 0x54, 0x33, 0x65, 0x5e, 0x27, 0xfd, 0x85, 0xee, 0xf7, 0xcc, 0x63, 0xc9, 0xfd,
	0xd7, 0xf4, 0x3e, 0x03, 0xe4, 0x6f, 0x02, 0xac, 0xc7, 0x27, 0x48, 0x01, 0xc7, 0xe3, 0x23, 0x3c,
	0x91, 0x2c, 0x3c, 0x48, 0xcf, 0xe6, 0x63, 0xdf, 0xb7, 0x5c, 0x27, 0xd6, 0xeb, 0x71, 0x49, 0xdb,
	0x4c, 0xb4, 0xf4, 0x85, 0x54, 0x4b, 0xff, 0x28, 0xf9, 0xb6, 0x52, 0xa4, 0xd5, 0x7b, 0xe2, 0xfd,
	0x64, 0x1a, 0x6a, 0xe2, 0xdd, 0x43, 0xed, 0xe4, 0x47, 0xb0, 0x6b, 0xb8, 0x76, 0x7d, 0xfa, 0x0f,
	0x35, 0xfe, 0xcd, 0x27, 0x9b, 0x1d, 0xfa, 0x57, 0xe5, 0x9f, 0xde, 0x13, 0x5e, 0x8b, 0xf4, 0x1f,
	0x7d, 0x7f, 0xcc, 0x17, 0x3b, 0x3f, 0xee, 0x9d, 0xfc, 0x29, 0x5f, 0x62, 0x80, 0x8b, 0x12, 0xe5,
	0x7f, 0xf6, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9c, 0x24, 0x27, 0x2f, 0x08, 0x1c, 0x00, 0x00,
}
