// Copyright 2017 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Nakama Protocol Buffers API
 *
 * This file describes the API used to communicate messages from Nakama Clients to the server.
 *
 * Author: The Nakama Authors
 */

syntax = "proto3";
package server;

option csharp_namespace = "Nakama";

/**
 * Heartbeat message used as server ping to check for client liveliness.
 * This is separate to any other protocol-level ping (e.g. Websocket PING).
 */
message Heartbeat {
  /// Server UTC timestamp in milliseconds.
  int64 timestamp = 1;
}

/**
 * An error that has occured on the server.
 * The error could be result of bad input, or unexpected system error.
 * Check Error Code for more info.
 */
message Error {
  /// Predefined errors that are produced by the server.
  enum Code {
    /// An unexpected error that is unrecoverable.
    RUNTIME_EXCEPTION = 0;
    /// Server received a message that is not recognized.
    UNRECOGNIZED_PAYLOAD = 1;
    /// Server received an Envelop message but the internal message is unrecognised. Most likely a protocol mismatch.
    MISSING_PAYLOAD = 2;
    /// The message did not include the required data in the correct format.
    BAD_INPUT = 3;
    /// Authentication failure.
    AUTH_ERROR = 4;
    /// Login failed because ID/device/email did not exist.
    USER_NOT_FOUND = 5;
    /// Registration failed because ID/device/email exists.
    USER_REGISTER_INUSE = 6;
    /// Linking operation failed because link exists.
    USER_LINK_INUSE = 7;
    /// Linking operation failed because third-party service was unreachable.
    USER_LINK_PROVIDER_UNAVAILABLE = 8;
    /// Unlinking operation failed because you cannot unlink last ID.
    USER_UNLINK_DISALLOWED = 9;
    /// Handle is in-use by another user.
    USER_HANDLE_INUSE = 10;
    /// Group names must be unique and it's already in use.
    GROUP_NAME_INUSE = 11;
    /// Storage write operation failed.
    STORAGE_REJECTED = 12;
    /// Match with given ID was not found in the system.
    MATCH_NOT_FOUND = 13;
    /// Runtime function name was not found in system registry.
    RUNTIME_FUNCTION_NOT_FOUND = 14;
    /// Runtime function caused an internal server error and did not complete.
    RUNTIME_FUNCTION_EXCEPTION = 15;
  }

  /// Error code - must be one of the Error.Code enums above.
  int32 code = 1;
  /// Specific error message.
  string message = 2;
}

/**
 * Authentication message used to register or login a user and generate a token.
 *
 * @returns AuthenticateResponse
 */
message AuthenticateRequest {
  /**
   * Email-based authentication.
   */
  message Email {
    /// Email address.
    string email = 1;
    /// Password.
    string password = 2;
  }

  /**
   * GameCenter authentication.
   *
   * https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign
   */
  message GameCenter {
    /// PlayerID generated by GameCenter.
    string player_id = 1;
    /// BundleID generated by GameCenter.
    string bundle_id = 2;
    /// The date and time that the signature was created.
    int64 timestamp = 3;
    /// A random NSString used to compute the hash and keep it randomized.
    string salt = 4;
    /// The verification signature data generated.
    string signature = 5;
    /// The URL for the public encryption key.
    string public_key_url = 6;
  }

  /// Optional collationID to track server response.
  string collationId = 1;

  /// OneOf authentication methods.
  oneof id {
    /// Email address and password.
    Email email = 2;
    /// Facebook OAuth Access Token.
    string facebook = 3;
    /// Google OAuth Access Token.
    string google = 4;
    /// GameCenter Authentication.
    GameCenter game_center = 5;
    /// Steam Token.
    string steam = 6;
    /// Device ID authentication.
    string device = 7;
    /// Custom ID authentication.
    string custom = 8;
  }
}

/**
 * Authentication message wrapper containing either a AuthenticateResponse.Session or AuthenticateResponse.Error.
 */
message AuthenticateResponse {
  /**
   * Authentication Session.
   */
  message Session {
    /// Authentication Token.
    string token = 1;
  }

  /**
   * Authentication Error.
   */
  message Error {
    /// Error code - this will be the same as the global error codes.
    int32 code = 1;
    /// Specific error message.
    string message = 2;
    /// Original request that caused this error.
    AuthenticateRequest request = 3;
  }

  /// Optional collationID to track server response.
  string collation_id = 1;

  /// OneOf authentication response.
  oneof id {
    /// Authentication session.
    Session session = 2;
    /// Authentication error.
    Error error = 3;
  }
}

/**
 * Main message wrapper containing a Payload and an optional Collation ID to track server responses.
 */
message Envelope {
  /// Optional collationID to track server response.
  string collation_id = 1;

  /// OneOf envelope payload. This can be both for request and response purposes.
  oneof payload {
    Error error = 2;

    Heartbeat heartbeat = 3;

    Logout logout = 4;
    TLink link = 5;
    TUnlink unlink = 6;

    TSelfFetch self_fetch = 7;
    TSelfUpdate self_update = 8;
    TUsersFetch users_fetch = 9;
    TSelf self = 10;
    TUsers users = 11;

    TFriendsAdd friends_add = 12;
    TFriendsRemove friends_remove = 13;
    TFriendsBlock friends_block = 14;
    TFriendsList friends_list = 15;
    TFriends friends = 16;

    TGroupsCreate groups_create = 17;
    TGroupsUpdate groups_update = 18;
    TGroupsRemove groups_remove = 19;
    TGroupsFetch groups_fetch = 20;
    TGroupsList groups_list = 21;
    TGroupsSelfList groups_self_list = 22;
    TGroupUsersList group_users_list = 23;
    TGroupsJoin groups_join = 24;
    TGroupsLeave groups_leave = 25;
    TGroupUsersAdd group_users_add = 26;
    TGroupUsersKick group_users_kick = 27;
    TGroupUsersPromote group_users_promote = 28;
    TGroups groups = 29;
    TGroupUsers group_users = 30;

    TTopicsJoin topics_join = 31;
    TTopicsLeave topics_leave = 32;
    TTopicMessageSend topic_message_send = 33;
    TTopicMessagesList topic_messages_list = 34;
    TTopics topics = 35;
    TTopicMessageAck topic_message_ack = 36;
    TopicMessage topic_message = 37;
    TTopicMessages topic_messages = 38;
    TopicPresence topic_presence = 39;

    TMatchCreate match_create = 40;
    TMatchesJoin matches_join = 41;
    TMatchesLeave matches_leave = 42;
    MatchDataSend match_data_send = 43;
    TMatch match = 44;
    TMatches matches = 45;
    MatchData match_data = 46;
    MatchPresence match_presence = 47;

    TStorageList storage_list = 48;
    TStorageFetch storage_fetch = 49;
    TStorageWrite storage_write = 50;
    TStorageUpdate storage_update = 51;
    TStorageRemove storage_remove = 52;
    TStorageData storage_data = 53;
    TStorageKeys storage_keys = 54;

    TLeaderboardsList leaderboards_list = 55;
    TLeaderboardRecordsWrite leaderboard_records_write = 56;
    TLeaderboardRecordsFetch leaderboard_records_fetch = 57;
    TLeaderboardRecordsList leaderboard_records_list = 58;
    TLeaderboards leaderboards = 59;
    TLeaderboardRecords leaderboard_records = 60;

    TMatchmakeAdd matchmake_add = 61;
    TMatchmakeRemove matchmake_remove = 62;
    TMatchmakeTicket matchmake_ticket = 63;
    MatchmakeMatched matchmake_matched = 64;

    TRpc rpc = 65;

    TPurchaseValidation purchase = 66;
    TPurchaseRecord purchase_record = 67;

    TNotificationsList notifications_list = 68;
    TNotificationsRemove notifications_remove = 69;
    TNotifications notifications = 70;
    Notifications live_notifications = 71;
  }
}

/**
 * Logout message used to gracefully disconnect the client from the server.
 * It will also blacklist the authentication session token.
 */
message Logout {}

/**
 * TLink message is used to link a profile with a user account
 * It expects same input as an authentication.
 */
message TLink {

  /// OneOf linking methods.
  oneof id {
    /// Email address and password.
    AuthenticateRequest.Email email = 1;
    /// Facebook OAuth Access Token.
    string facebook = 2;
    /// Google OAuth Access Token.
    string google = 3;
    /// GameCenter.
    AuthenticateRequest.GameCenter game_center = 4;
    /// Steam Token.
    string steam = 5;
    /// Device ID.
    string device = 6;
    /// Custom ID.
    string custom = 7;
  }
}

/**
 * TUnlink message is used to unlink a profile with a user account
 * Unlink allows direct IDs, no tokens needed.
 */
message TUnlink {

  /// OneOf unlinking methods.
  oneof id {
    /// Email address.
    string email = 1;
    /// Facebook ID.
    string facebook = 2;
    /// Google ID.
    string google = 3;
    /// GameCenter ID.
    string game_center = 4;
    /// Steam ID.
    string steam = 5;
    /// Device ID.
    string device = 6;
    /// Custom ID.
    string custom = 7;
  }
}

/**
 * User is the core domain type representing a user in Nakama.
 */
message User {
  /// User ID.
  bytes id = 1;
  /// User Handle (username).
  string handle = 2;
  /// User's fullname.
  string fullname = 3;
  /// Link to avatar.
  string avatar_url = 4;
  /// Language tag corresponding to the BCP 47 spec.
  string lang = 5;
  /// User's location.
  string location = 6;
  /// User's timezone.
  string timezone = 7;
  /// Custom user metadata.
  bytes metadata = 8;
  /// Unix timestamp when this user registered.
  int64 created_at = 9;
  /// Unix timestamp when user profile was last changed.
  int64 updated_at = 10;
  /// Unix timestamp when user was last connected.
  int64 last_online_at = 11;
}

/**
 * Self is the core domain type representing the currently connected user in Nakama.
 * Alongside the normal user properties, it also contains various other fields only relevant for the current user.
 */
message Self {
  /// User's account.
  User user = 1;
  /// Whether the user was verified, either via email or social accounts.
  bool verified = 2;
  /// User's email address.
  string email = 3;
  /// List of device IDs the user has.
  repeated string device_ids = 4;
  /// User's Facebook ID.
  string facebook_id = 5;
  /// User's Google ID.
  string google_id = 6;
  /// User's Game Center ID.
  string gamecenter_id = 7;
  /// User's Steam ID.
  string steam_id = 8;
  /// Custom ID associated with the user.
  string custom_id = 9;
}

/**
 * TSelfFetch message is used to send a request to retrieve the user account associated with the currently connected user.
 *
 * @returns TSelf
 */
message TSelfFetch {}

/**
 * TSelf is the user account and any other associated IDs with the user.
 */
message TSelf {
  Self self = 1;
}

/**
 * TSelfUpdate message is used to update parts of the user account associated with the currently connected user.
 */
message TSelfUpdate {
  string handle = 1;
  string fullname = 2;
  string timezone = 3;
  string location = 4;
  /// Language tag corresponding to the BCP 47 spec
  string lang = 5;
  /// Set or remove User's metadata
  bytes metadata = 6;
  string avatar_url = 7;
}

/**
 * TUsersFetch fetches a list of users that match the given set of user IDs or user Handles.
 *
 * @returns TUsers
 */
message TUsersFetch {
  message UsersFetch {
    oneof id {
      bytes user_id = 1;
      string handle = 2;
    }
  }

  /// Must at least contain one item.
  repeated UsersFetch users = 1;
}

/**
 * TUsers contains a list of Users. The list could be empty.
 */
message TUsers {
  repeated User users = 1;
}

/**
 * Friend is the core domain type representing a friend relationship in Nakama.
 */
message Friend {
  /// The user that is the friend of the currently connected user.
  User user = 1;
  /// The type of relationship this is. The value can be one of the following:
  /// Friend(0): Mutual friendship.
  /// Invite(1): Current user has sent an invitation.
  /// Invited(2): Current user has received an invitation.
  /// Blocked(3): Current user has blocked this friend.
  int64 type = 2;
}

/**
 * TFriendsAdd sends a list of user IDs or handles to the server that the current user would like to form a friendship with.
 * If a reverse relationship already exists, then a mutual friendship is formed, otherwise a friendship request is recorded for the user.
 */
message TFriendsAdd {
  message FriendsAdd {
    oneof id {
      bytes user_id = 1;
      string handle = 2;
    }
  }

  repeated FriendsAdd friends = 1;
}

/**
 * TFriendsRemove sends a list of user IDs or handles to the server that the current user would like to remove relationship status from.
 * This could be unfriending a friend, or removing a friend request.
 */
message TFriendsRemove {
  repeated bytes user_ids = 1;
}

/**
 * TFriendsBlock sends a list of user IDs or handles to the server that the current user would like to block.
 * If the current user is a friend, relationship is removed bidirectionaly from both users and a new Block status is formed.
 */
message TFriendsBlock {
  repeated bytes user_ids = 1;
}

/**
 * TFriendsList fetches a list of users that have a relationship with the current user.
 *
 * @returns TFriends
 */
message TFriendsList {}

/**
 * TUsers contains a list of Friends. The list could be empty.
 */
message TFriends {
  repeated Friend friends = 1;
}

/**
 * Group is the core domain type representing a group of users in Nakama.
 */
message Group {
  /// Group ID
  bytes id = 1;
  /// Whether the group is private or public. If private, group admins will accept user join requests.
  bool private = 2;
  /// User ID of the group creator.
  bytes creator_id = 3;
  string name = 4;
  string description = 5;
  string avatar_url = 6;
  /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
  string lang = 7;
  /// Offset time in millisecond from UTC.
  int64 utc_offset_ms = 8;
  /// Group metadata information.
  bytes metadata = 9;
  /// Current number of users in this group.
  int64 count = 10;
  int64 created_at = 11;
  int64 updated_at = 12;
}

/**
 * TGroupsCreate creates a new group.
 *
 * @returns TGroups
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupsCreate {
  message GroupCreate {
    /// Group name must be unique.
    string name = 1;
    string description = 2;
    string avatar_url = 3;
    /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
    string lang = 4;
    /// Group metadata information.
    bytes metadata = 5;
    /// Whether the group is private or public. If private, group admins will accept user join requests.
    bool private = 6;
  }
  repeated GroupCreate groups = 1;
}

/**
 * TGroupsUpdate updates the group with matching Group ID.
 * Only group admins can update group information.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupsUpdate {
  message GroupUpdate {
    bytes group_id = 1;
    /// Whether the group is private or public. If private, group admins will accept user join requests.
    bool private = 2;
    /// Group name must be unique.
    string name = 3;
    string description = 4;
    string avatar_url = 5;
    /// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
    string lang = 6;
    /// Set or remove metadata information.
    bytes metadata = 7;
  }

  repeated GroupUpdate groups = 1;
}

/**
 * TGroupsRemove removes the group with matching Group ID.
 * Only group admins can delete group.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupsRemove {
  repeated bytes group_ids = 1;
}

/**
 * TGroupsSelfList fetches a list of groups that the current user is part of.
 *
 * @returns TGroups
 */
message TGroupsSelfList {}

/**
 * TGroupsFetch fetches a list of groups that the match the group ID or group name.
 *
 * @returns TGroups
 */
message TGroupsFetch {
  message GroupFetch {
    oneof id {
      bytes group_id = 1;
      string name = 2;
    }
  }

  repeated GroupFetch groups = 1;
}

/**
 * TGroupsList searches all groups for matching criteria.
 *
 * @returns TGroups
 */
message TGroupsList {
  /// Upper limit on the maximum number of groups to return per request. Max value is 100.
  int64 page_limit = 1;
  /// Whether to order the result ascending or descending based on the filters defined below.
  bool order_by_asc = 2;
  /// Filter used to search for groups.
  oneof filter {
    /// Find groups matching the given language tag.
    string lang = 3; // >= for lang variations
    /// Find groups created after a given time.
    int64 created_at = 4; // >= after the given time
    /// Find groups that have members up to (and equal to) the count value.
    int64 count = 5; // up to max count, <= anything less than or equal to given count.
  }
  /// Binary cursor value used to paginate results.
  /// The value of this comes from TGroups.cursor.
  bytes cursor = 7; // gob(%{struct(int64/string, int64, bytes)})
}

/**
 * TGroups contains a list of groups and a cursor that can be used to further paginate results.
 */
message TGroups {
  repeated Group groups = 1;
  /// Use cursor to paginate results.
  bytes cursor = 2;
}

/**
 * GroupUser is the core domain type representing a user that belongs to a group and their relationship status with the group.
 */
message GroupUser {
  User user = 1;
  /// The type of relationship this is. The value can be one of the following:
  /// Admin(0): User is an admin for this group.
  /// Member(1): User is a regular member of this group.
  /// Join(2): User is currently waiting to be accepted in this group.
  int64 type = 2;
}

/**
 * TGroupsList fetches list of users in the given group.
 *
 * @returns TGroupUsers
 */
message TGroupUsersList {
  bytes group_id = 1;
}

/**
 * TGroupUsers contains all users and their relationship in a group.
 */
message TGroupUsers {
  repeated GroupUser users = 1;
}


/**
 * TGroupsJoin adds the currently connected user to the groups below.
 * If the group is private, they are added to a waiting queue until a group admin accepts or reject the request.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupsJoin {
  repeated bytes group_ids = 1;
}

/**
 * TGroupsLeave removes the currently connected user from group below.
 * The user won't be able to leave if they are last admin, instead delete the group.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupsLeave {
  repeated bytes group_ids = 1;
}

/**
 * TGroupUsersAdd adds a list of users to a list of groups by the currently connected user.
 * The current user must be an admin of *ALL* groups otherwise the request fails.
 * This is also the way to accept a group join request.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupUsersAdd {
  message GroupUserAdd {
    bytes group_id = 1;
    bytes user_id = 2;
  }

  repeated GroupUserAdd group_users = 1;
}

/**
 * TGroupUsersKick removes a list of users from a list of groups by the currently connected user.
 * The current user must be an admin of *ALL* groups otherwise the request fails.
 * This is also the way to reject a group join request.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupUsersKick {
  message GroupUserKick {
    bytes group_id = 1;
    bytes user_id = 2;
  }
  repeated GroupUserKick group_users = 1;
}

/**
 * TGroupUsersPromote updates a list of regular users to have group admin priviliges for a list of groups by the currently connected user.
 * The current user must be an admin of *ALL* groups otherwise the request fails.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TGroupUsersPromote {
  message GroupUserPromote {
    bytes group_id = 1;
    bytes user_id = 2;
  }
  repeated GroupUserPromote group_users = 1;
}

/**
 * TopicId is the core domain type representing a chat topic identifier.
 */
message TopicId {
  oneof id {
    bytes dm = 1;
    bytes room = 2;
    bytes group_id = 3;
  }
}

/**
 * UserPresence is the core domain type representing a presense in chat topic.
 * A user can have multiple presences
 */
message UserPresence {
  /// User ID
  bytes user_id = 1;
  /// Session ID
  bytes session_id = 2;
  /// User handle
  string handle = 3;
}

/**
 * TTopicsJoin adds the current user's session to a chat topic.
 *
 * @returns TTopics
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TTopicsJoin {
  message TopicJoin {
    oneof id {
      bytes user_id = 1;
      bytes room = 2;
      bytes group_id = 3;
    }
  }

  repeated TopicJoin joins = 1;
}

/**
 * List of new topics that the session has joined.
 */
message TTopics {
  message Topic {
    /// Chat topics
    TopicId topic = 1;
    /// List of chat presences in the topic
    repeated UserPresence presences = 2;
    /// Current user's chat presence
    UserPresence self = 3;
  }

  repeated Topic topics = 1;
}

/**
 * TTopicsLeave removes the current user's session from the chat topic.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TTopicsLeave {
  repeated TopicId topics = 1;
}

/**
 * TTopicMessageSend sends a message to the topic
 */
message TTopicMessageSend {
  TopicId topic = 1;
  bytes data = 2;
}

/**
 * TTopicMessageAck sends an ack message to the topic
 */
message TTopicMessageAck {
  bytes message_id = 1;
  int64 created_at = 2;
  int64 expires_at = 3;
  string handle = 4;
}

/**
 * TopicMessage is the core domain type representing a chat message that is sent by another user.
 */
message TopicMessage {
  TopicId topic = 1;
  bytes user_id = 2;
  bytes message_id = 3;
  int64 created_at = 4;
  int64 expires_at = 5;
  string handle = 6;
  /// The chat message types are:
  /// Chat message (0) - Chat messages sent by users
  /// Group Join (1) - Notification - a user joined the group - send by the system
  /// Group Add (2) - Notification - a user was added/accepted to the group - send by the system
  /// Group Leave (3) - Notification - a user left the group - send by the system
  /// Group Kick (4) - Notification - a user was kicked from the group - send by the system
  /// Group Promoted (5) - Notification - a user was promoted to group admin - send by the system
  int64 type = 7;
  bytes data = 8;
}

/**
 * TTopicMessagesList retrieves a list of historic messages for a topic.
 *
 * @returns TTopicMessages
 */
message TTopicMessagesList {
  oneof id {
    bytes user_id = 1;
    bytes room = 2;
    bytes group_id = 3;
  }
  /// Use the cursor to paginate through more message.
  /// The value of this comes from TTopicMessages.cursor.
  bytes cursor = 4;
  bool forward = 5;
  int64 limit = 6;
}

/**
 * TTopicMessages is a list of historic messages for a topic.
 */
message TTopicMessages {
  repeated TopicMessage messages = 1;
  bytes cursor = 2;
}

/**
 * TopicPresence is the core domain type representing a change presences for a topic.
 */
message TopicPresence {
  TopicId topic = 1;
  repeated UserPresence joins = 2;
  repeated UserPresence leaves = 3;
}

/**
 * TMatchmakeAdd is used to add the current user to the matchmaking pool.
 *
 * @returns TMatchmakeTicket
 */
message TMatchmakeAdd {
  /// Match user with other users looking for a match with the the following number of users.
  int64 requiredCount = 1;
}

/**
 * TMatchmakeTicket represents a matchmake ticket. Use the ticket to cancel matchmaking search.
 */
message TMatchmakeTicket {
  bytes ticket = 1;
}

/**
 * TMatchmakeRemove is used to cancel a matchmake search.
 */
message TMatchmakeRemove {
  bytes ticket = 1;
}

/**
 * MatchmakeMatched is the core domain type representing a found match via matchmaking.
 */
message MatchmakeMatched {
  /// Matchmaking ticket. Use this to invalidate ticket cache on the client.
  bytes ticket = 1;
  /// Matchmaking token. Use this to accept the match. This is a onetime token which is only valid for 15seconds.
  bytes token = 2;
  repeated UserPresence presences = 3;
  UserPresence self = 4;
}

/**
 * Match is the core domain type representing an on-going match.
 */
message Match {
  bytes match_id = 1;
  repeated UserPresence presences = 2;
  UserPresence self = 3;
}

/**
 * MatchPresence is the core domain type representing the users participating and leaving a match.
 */
message MatchPresence {
  bytes match_id = 1;
  repeated UserPresence joins = 2;
  repeated UserPresence leaves = 3;
}

/**
 * TMatchCreate is used to create a new match from scratch. Use TMatchesJoin to make other users join the match.
 *
 * @returns TMatch
 */
message TMatchCreate {}

/**
 * TMatch contains a match object.
 */
message TMatch {
  Match match = 1;
}

/**
 * TMatchesJoin is used to join existing matches.
 *
 * @returns TMatches
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TMatchesJoin {
  message MatchJoin {
    oneof id {
      bytes match_id = 1;
      bytes token = 2;
    }
  }

  repeated MatchJoin matches = 1;
}

/**
 * TMatch contains a list of matches.
 */
message TMatches {
  repeated Match matches = 1;
}

/**
 * MatchDataSend is used to send match data to the server.
 */
message MatchDataSend {
  bytes match_id = 1;
  /// Custom Op code to make disguishing different message types easier.
  int64 op_code = 2;
  bytes data = 3;
  repeated UserPresence presences = 4;
}

/**
 * MatchData is the core domain type representing a match data.
 */
message MatchData {
  bytes match_id = 1;
  UserPresence presence = 2;
  int64 op_code = 3;
  bytes data = 4;
}

/**
 * TMatchesLeave is used to leave an existing matches.
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TMatchesLeave {
  repeated bytes match_ids = 1;
}

/**
 * StoragePermissionRead is the core domain type representing Storage Read permission
 */
enum StoragePermissionRead {
  /// Storage owner does not have read access.
  NO_READ = 0;
  /// Only storage owner has read access.
  OWNER_READ = 1;
  /// Storage owner and every other user has read access.
  PUBLIC_READ = 2;
}

/**
 * StoragePermissionWrite is the core domain type representing Storage Write permission
 */
enum StoragePermissionWrite {
  /// Storage owner does not have write access.
  NO_WRITE = 0;
  /// Storage owner has write access.
  OWNER_WRITE = 1;
}

/**
 * TStorageList is used to list records from Storage
 *
 * @returns TStorageData
 */
message TStorageList {
  bytes user_id = 1;
  string bucket = 2;
  string collection = 3;
  int64 limit = 4;
  bytes cursor = 5;
}

/**
 * TStorageFetch is used to retrieve a list of records from Storage
 *
 * @returns TStorageData
 */
message TStorageFetch {
  message StorageKey {
    string bucket = 1;
    string collection = 2;
    string record = 3;
    bytes user_id = 4;
  }
  repeated StorageKey keys = 1;
}

/**
 * TStorageData contains a list of Storage data records.
 */
message TStorageData {
  message StorageData {
    string bucket = 1;
    string collection = 2;
    string record = 3;
    bytes user_id = 4;
    bytes value = 5;
    bytes version = 6;
    int32 permission_read = 7;
    int32 permission_write = 8;
    int64 created_at = 9;
    int64 updated_at = 10;
    int64 expires_at = 11;
  }

  repeated StorageData data = 1;
  bytes cursor = 2;
}

/**
 * TStorageWrite is used to store a list of records to Storage.
 *
 * The server provides transactional gurantuees. If one record fails to be inserted,
 * the entire operation is rolled backed and marked as an error.
 *
 * @returns TStorageKey
 */
message TStorageWrite {
  message StorageData {
    string bucket = 1;
    string collection = 2;
    string record = 3;
    bytes value = 4;
    bytes version = 5; // if-match and if-none-match
    int32 permission_read = 6;
    int32 permission_write = 7;
  }

  repeated StorageData data = 3;
}

/**
 * TStorageUpdate is used to update a list of records in Storage.
 *
 * The server provides transactional gurantuees. If one record fails to be updated,
 * the entire operation is rolled backed and marked as an error.
 *
 * @returns TStorageKey
 */
message TStorageUpdate {
  message StorageUpdate {

    message UpdateOp {
      enum UpdateOpCode {
        /// Add field or value to array at the path.
        ADD = 0;
        /// Append a value or array of values at the path.
        APPEND = 1;
        /// Copy value at the path to another path.
        COPY = 2;
        /// Add a positive/negative value to the value at the path.
        INCR = 3;
        /// Initialize the value at the path ONLY if it’s not already present.
        INIT = 4;
        /// Perform a merge of the object at the path.
        MERGE = 5;
        /// Move a value from one path to another and remove from the original path.
        MOVE = 6;
        /// Perform a JSON patch with the sequence of operations on the subpath specified
        PATCH = 7;
        /// Remove the value or array at the path.
        REMOVE = 8;
        /// Replaces an existing value at the specified path.
        REPLACE = 9;
        /// Tests equality of the value at the path. The entire patch set fails if the test fails.
        TEST = 10;
        /// Performs a comparator which returns -1, 0, or 1 depending on whether the value is less than, the same, or greater than the value in the path.
        COMPARE = 11;
      }

      /// Update op code - must be one of the UpdateOpCode enums above.
      int32 op = 1;
      string path = 2;
      bytes value = 3;
      string from = 4;
      bool conditional = 5;
      int64 assert = 6;
    }

    message StorageKey {
      string bucket = 1;
      string collection = 2;
      string record = 3;
      bytes version = 4; // if-match and if-none-match
    }

    StorageKey key = 1;
    int32 permission_read = 2;
    int32 permission_write = 3;
    repeated UpdateOp ops = 4;
  }

  repeated StorageUpdate updates = 1;
}

/**
 * TStorageKey contains a list of Storage keys for the newly stored data.
 */
message TStorageKeys {
  message StorageKey {
    string bucket = 1;
    string collection = 2;
    string record = 3;
    bytes version = 4;
  }

  repeated StorageKey keys = 1;
}

/**
 * TStorageRemove is used to remove a list of records from Storage.
 *
 * The server provides transactional gurantuees. If one record fails to be deleted,
 * the entire operation is rolled backed and marked as an error.
 */
message TStorageRemove {
  message StorageKey {
    string bucket = 1;
    string collection = 2;
    string record = 3;
    bytes version = 4;
  }
  repeated StorageKey keys = 1;
}

/**
 * Leaderboard is the core domain type representing a Leaderboard setup in the server.
 */
message Leaderboard {
  bytes id = 1;
  /// Whether the user can submit records directly via the client or not
  bool authoritative = 2;
  int64 sort = 3;
  int64 count = 4;
  string reset_schedule = 5;
  bytes metadata = 6;
  bytes next_id = 7;
  bytes prev_id = 8;
}

/**
 * LeaderboardRecord is the core domain type representing a Leaderboard entry.
 */
message LeaderboardRecord {
  bytes leaderboard_id = 1;
  bytes owner_id = 2;
  string handle = 3;
  /// Language tag corresponding to the BCP 47 spec.
  string lang = 4;
  string location = 5;
  string timezone = 6;
  int64 rank = 7;
  int64 score = 8;
  int64 num_score = 9;
  bytes metadata = 10;
  int64 ranked_at = 11;
  int64 updated_at = 12;
  int64 expires_at = 13;
}

/**
 * TLeaderboardsList is used to retrieve a list of leaderboards.
 *
 * A list of IDs can be supplied optionally, otherwise all leaderboards are returned.
 *
 * @returns TLeaderboards
 */
message TLeaderboardsList {
  int64 limit = 1;
  /// Use TLeaderboards.cursor to paginate through results.
  bytes cursor = 2;
  repeated bytes filter_leaderboard_id = 3;
}

/**
 * TLeaderboards contains a list of leaderboards.
 */
message TLeaderboards {
  repeated Leaderboard leaderboards = 1;
  bytes cursor = 2;
}

/**
 * TLeaderboardRecordsWrite is used to write new list of records to a given list of leaderboards.
 *
 * @returns TLeaderboardRecords
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TLeaderboardRecordsWrite {
  message LeaderboardRecordWrite {
    bytes leaderboard_id = 1;
    oneof op {
      int64 incr = 2;
      int64 decr = 3;
      int64 set = 4;
      int64 best = 5;
    }
    string location = 6;
    string timezone = 7;
    bytes metadata = 8;
  }

  repeated LeaderboardRecordWrite records = 1;
}

/**
 * TLeaderboardRecordsFetch is used to retrieve a list of records from a given list of leaderboards.
 *
 * @returns TLeaderboardRecords
 *
 * NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
 */
message TLeaderboardRecordsFetch {
  repeated bytes leaderboard_ids = 1;
  int64 limit = 2;
  /// Use TLeaderboardRecords.cursor to paginate through results.
  bytes cursor = 3;
}

/**
 * TLeaderboardRecordsList is used to retrieve a list of records from a given list of leaderboards with given preset filters.
 *
 * @returns TLeaderboardRecords
 */
message TLeaderboardRecordsList {
  message Owners {
    repeated bytes owner_ids = 1;
  }

  bytes leaderboard_id = 1;
  oneof filter {
    /// Filter records by one user ID. This is the same as a "heystack" lookup
    bytes owner_id = 2; // "haystack" lookup
    /// Filter records by user IDs
    Owners owner_ids = 3;
    string lang = 4;
    string location = 5;
    string timezone = 6;
  }
  int64 limit = 7;
  bytes cursor = 8;
}

/**
 * TLeaderboardRecords contains a list of leaderboard records.
 */
message TLeaderboardRecords {
  repeated LeaderboardRecord records = 1;
  bytes cursor = 2;
}

/**
 * TRpc is used to directly invoke the Lua runtime with the given payload.
 * The script can optionally return some data which will be marshalled into the payload field and sent back to the client.
 *
 * @returns TRpc
 */
message TRpc {
  string id = 1;
  bytes payload = 2;
}

/**
 * TPurchaseValidation is used to validation purchases made by the client.
 * Verify an In-App Purchase receipt from Apple or Google purchases.
 *
 * @returns TPurchaseRecord
 */
message TPurchaseValidation {
  /**
   * Verify an In-App Purchase receipt from Apple purchases.
   */
  message ApplePurchase {
    // The product, item, or subscription package ID the purchase relates to.
    string product_id = 1;
    // The receipt data returned by the purchase operation itself. This must be converted to base64.
    string receipt_data = 2;
  }

  /**
   * Verify an In-App Purchase receipt from Google purchases.
   */
  message GooglePurchase {
    // The identifier of the product or subscription being purchased.
    string product_id = 1;
    // Whether the purchase is for a single product or a subscription.
    string product_type = 2;
    // The token returned in the purchase operation response, acts as a transaction identifier.
    string purchase_token = 3;
  }

  oneof id {
    ApplePurchase apple_purchase = 1;
    GooglePurchase google_purchase = 2;
  }
}

/**
 * TPurchaseRecord is the response of purchase validation
 */
message TPurchaseRecord {
  /// Whether or not the transaction is valid and all the information matches.
  bool success = 1;
  /// If this is a new transaction or if Nakama has a log of it.
  bool seen_before = 2;
  /// Indicates whether or not Nakama was able to reach the remote purchase service.
  bool purchase_provider_reachable = 3;
  /// A string indicating why the purchase verification failed, if appropriate.
  string message = 6;
  /// The complete response Nakama received from the remote service.
  string data = 5;
}

/**
 * Notification is the core domain type representing an in-app notification.
 */
message Notification {
  bytes id = 1;
  string subject = 2;
  bytes content = 3;
  int64 code = 4;
  bytes sender_id = 5;
  int64 created_at = 6;
  int64 expires_at = 7;
  bool persistent = 8;
}

/**
 * Notification is the core domain type representing a list of live in-app notification.
 */
message Notifications {
  repeated Notification notifications = 1;
}

/**
 * TNotificationsList is used to list unexpired notifications.
 */
message TNotificationsList {
  /// Max number of notifications to list. Between 10 and 100.
  int64 limit = 1;
  /// Use this cursor to paginate notifications.
  /// Cache this to catch up to new notifications.
  /// The value of this comes from TNotifications.resumable_cursor.
  bytes resumable_cursor = 2;
}

/**
 * TNotifications is the response of listing notifications
 */
message TNotifications {
  repeated Notification notifications = 1;
  /// Use this cursor to paginate notifications.
  /// Cache this to catch up to new notifications.
  bytes resumable_cursor = 2;
}

/**
 * TNotificationsRemove is used to delete notifications.
 */
message TNotificationsRemove {
  repeated bytes notification_ids = 1;
}
