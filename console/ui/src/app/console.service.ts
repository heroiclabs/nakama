// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';

/** Account information. */
export interface Account {
  // The user's account details.
	account?:ApiAccount
  // The UNIX time when the account was disabled.
	disable_time?:string
}

/** An export of all information stored for a user account. */
export interface AccountExport {
  // The user's account details.
	account?:ApiAccount
  // The user's friends.
	friends?:Array<ApiFriend>
  // The user's groups.
	groups?:Array<ApiGroup>
  // The user's leaderboard records.
	leaderboard_records?:Array<ApiLeaderboardRecord>
  // The user's chat messages.
	messages?:Array<ApiChannelMessage>
  // The user's notifications.
	notifications?:Array<ApiNotification>
  // The user's storage.
	objects?:Array<ApiStorageObject>
  // The user's wallet ledger items.
	wallet_ledgers?:Array<WalletLedger>
}

/** A list of users. */
export interface AccountList {
  // Next cursor.
	next_cursor?:string
  // Approximate total number of users.
	total_count?:number
  // A list of users.
	users?:Array<ApiUser>
}

/**  */
export interface AddUserRequest {
  // Email address of the user.
	email?:string
  // 
	newsletter_subscription?:boolean
  // The password of the user.
	password?:string
  // 
	role?:UserRole
  // The username of the user.
	username?:string
}

/**  */
export interface ApiEndpointDescriptor {
  // 
	body_template?:string
  // 
	method?:string
}

/**  */
export interface ApiEndpointList {
  // 
	endpoints?:Array<ApiEndpointDescriptor>
  // 
	rpc_endpoints?:Array<ApiEndpointDescriptor>
}

/** Authenticate a console user with username and password. */
export interface AuthenticateRequest {
  // The password of the user.
	password?:string
  // The username of the user.
	username?:string
}

/**  */
export interface CallApiEndpointResponse {
  // 
	body?:string
  // 
	error_message?:string
}

/** The current server configuration and any associated warnings. */
export interface Config {
  // JSON-encoded active server configuration.
	config?:string
  // 
	server_version?:string
  // Any warnings about the current config.
	warnings?:Array<ConfigWarning>
}

/** A warning for a configuration field. */
export interface ConfigWarning {
  // The config field this warning is for in a JSON pointer format.
	field?:string
  // Warning message text.
	message?:string
}

/** A console user session. */
export interface ConsoleSession {
  // A session token (JWT) for the console user.
	token?:string
}

/** An export of all information stored for a group. */
export interface GroupExport {
  // The group details.
	group?:ApiGroup
  // The group's list of members.
	members?:Array<GroupUserListGroupUser>
}

/**  */
export interface GroupList {
  // A list of groups.
	groups?:Array<ApiGroup>
  // Next cursor.
	next_cursor?:string
  // Approximate total number of groups.
	total_count?:number
}

/** A single user-role pair. */
export interface GroupUserListGroupUser {
  // Their relationship to the group.
	state?:number
  // User.
	user?:ApiUser
}

/** A leaderboard. */
export interface Leaderboard {
  // Authoritative.
	authoritative?:boolean
  // The category of the leaderboard. e.g. "vip" could be category 1.
	category?:number
  // The UNIX time when the leaderboard was created.
	create_time?:string
  // The description of the leaderboard. May be blank.
	description?:string
  // Duration of the tournament in seconds.
	duration?:number
  // The UNIX time when the leaderboard stops being active until next reset. A computed value.
	end_active?:number
  // The UNIX time when the leaderboard will be stopped.
	end_time?:string
  // The ID of the leaderboard.
	id?:string
  // Join required.
	join_required?:boolean
  // The maximum score updates allowed per player for the current leaderboard.
	max_num_score?:number
  // The maximum number of players for the leaderboard.
	max_size?:number
  // Additional information stored as a JSON object.
	metadata?:string
  // 
	operator?:number
  // Reset cron expression.
	reset_schedule?:string
  // The current number of players in the leaderboard.
	size?:number
  // ASC or DESC sort mode of scores in the leaderboard.
	sort_order?:number
  // The UNIX time when the leaderboard start being active. A computed value.
	start_active?:number
  // The UNIX time when the leaderboard will start.
	start_time?:string
  // The title for the leaderboard.
	title?:string
  // Tournament.
	tournament?:boolean
}

/** A list of leaderboards. */
export interface LeaderboardList {
  // The list of leaderboards returned.
	leaderboards?:Array<Leaderboard>
}

/**  */
export interface MatchState {
  // Presence list.
	presences?:Array<RealtimeUserPresence>
  // State.
	state?:string
  // Current tick number.
	tick?:string
}

/**  */
export interface RuntimeInfo {
  // 
	go_modules?:Array<RuntimeInfoModuleInfo>
  // 
	go_rpc_functions?:Array<string>
  // 
	js_modules?:Array<RuntimeInfoModuleInfo>
  // 
	js_rpc_functions?:Array<string>
  // 
	lua_modules?:Array<RuntimeInfoModuleInfo>
  // 
	lua_rpc_functions?:Array<string>
}

/**  */
export interface RuntimeInfoModuleInfo {
  // 
	mod_time?:string
  // 
	path?:string
}

/**  */
export enum StatusHealth {
    STATUS_HEALTH_OK = 0,
    STATUS_HEALTH_ERROR = 1,
    STATUS_HEALTH_CONNECTING = 2,
    STATUS_HEALTH_DISCONNECTING = 3,
}

/** List of nodes and their stats. */
export interface StatusList {
  // List of nodes and their stats.
	nodes?:Array<StatusListStatus>
  // 
	timestamp?:string
}

/** The status of a Nakama node. */
export interface StatusListStatus {
  // Average input bandwidth usage.
	avg_input_kbs?:number
  // Average response latency in milliseconds.
	avg_latency_ms?:number
  // Average output bandwidth usage.
	avg_output_kbs?:number
  // Average number of requests per second.
	avg_rate_sec?:number
  // Current number of running goroutines.
	goroutine_count?:number
  // Health score.
	health?:StatusHealth
  // Current number of active authoritative matches.
	match_count?:number
  // Node name.
	name?:string
  // Currently registered live presences.
	presence_count?:number
  // Currently connected sessions.
	session_count?:number
}

/**  */
export interface StorageCollectionsList {
  // 
	collections?:Array<string>
}

/** List of storage objects. */
export interface StorageList {
  // 
	next_cursor?:string
  // List of storage objects matching list/filter operation.
	objects?:Array<ApiStorageObject>
  // Approximate total number of storage objects.
	total_count?:number
}

/** A single group-role pair. */
export interface UserGroupListUserGroup {
  // Group.
	group?:ApiGroup
  // The user's relationship to the group.
	state?:number
}

/** A list of console users. */
export interface UserList {
  // A list of users.
	users?:Array<UserListUser>
}

/**  */
export interface UserListUser {
  // 
	email?:string
  // 
	role?:UserRole
  // 
	username?:string
}

/**  */
export enum UserRole {
    USER_ROLE_UNKNOWN = 0,
    USER_ROLE_ADMIN = 1,
    USER_ROLE_DEVELOPER = 2,
    USER_ROLE_MAINTAINER = 3,
    USER_ROLE_READONLY = 4,
}

/** Environment where the purchase took place */
export enum ValidatedPurchaseEnvironment {
    UNKNOWN = 0,
    SANDBOX = 1,
    PRODUCTION = 2,
}

/** Validation Provider */
export enum ValidatedPurchaseStore {
    APPLE_APP_STORE = 0,
    GOOGLE_PLAY_STORE = 1,
    HUAWEI_APP_GALLERY = 2,
}

/** An individual update to a user's wallet. */
export interface WalletLedger {
  // The changeset.
	changeset?:string
  // The UNIX time when the wallet ledger item was created.
	create_time?:string
  // The identifier of this wallet change.
	id?:string
  // Any associated metadata.
	metadata?:string
  // The UNIX time when the wallet ledger item was updated.
	update_time?:string
  // The user ID this wallet ledger item belongs to.
	user_id?:string
}

/** List of wallet ledger items for a particular user. */
export interface WalletLedgerList {
  // A list of wallet ledger items.
	items?:Array<WalletLedger>
  // The cursor to send when retrieving the next older page, if any.
	next_cursor?:string
  // The cursor to send when retrieving the previous page newer, if any.
	prev_cursor?:string
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  // The custom id in the user's account.
	custom_id?:string
  // The devices which belong to the user's account.
	devices?:Array<ApiAccountDevice>
  // The UNIX time when the user's account was disabled/banned.
	disable_time?:string
  // The email address of the user.
	email?:string
  // The user object.
	user?:ApiUser
  // The UNIX time when the user's email was verified.
	verify_time?:string
  // The user's wallet data.
	wallet?:string
}

/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  // A device identifier. Should be obtained by a platform-specific device API.
	id?:string
  // Extra information that will be bundled in the session token.
	vars?:Map<string, string>
}

/** A message sent on a channel. */
export interface ApiChannelMessage {
  // The channel this message belongs to.
	channel_id?:string
  // The code representing a message type or category.
	code?:number
  // The content payload.
	content?:string
  // The UNIX time when the message was created.
	create_time?:string
  // The ID of the group, or an empty string if this message was not sent through a group channel.
	group_id?:string
  // The unique ID of this message.
	message_id?:string
  // True if the message was persisted to the channel's history, false otherwise.
	persistent?:boolean
  // The name of the chat room, or an empty string if this message was not sent through a chat room.
	room_name?:string
  // Message sender, usually a user ID.
	sender_id?:string
  // The UNIX time when the message was last updated.
	update_time?:string
  // The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
	user_id_one?:string
  // The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
	user_id_two?:string
  // The username of the message sender, if any.
	username?:string
}

/** A friend of a user. */
export interface ApiFriend {
  // The friend status.
	state?:number
  // Time of the latest relationship update.
	update_time?:string
  // The user object.
	user?:ApiUser
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  // Cursor for the next page of results, if any.
	cursor?:string
  // The Friend objects.
	friends?:Array<ApiFriend>
}

/** A group in the server. */
export interface ApiGroup {
  // A URL for an avatar image.
	avatar_url?:string
  // The UNIX time when the group was created.
	create_time?:string
  // The id of the user who created the group.
	creator_id?:string
  // A description for the group.
	description?:string
  // The current count of all members in the group.
	edge_count?:number
  // The id of a group.
	id?:string
  // The language expected to be a tag which follows the BCP-47 spec.
	lang_tag?:string
  // The maximum number of members allowed.
	max_count?:number
  // Additional information stored as a JSON object.
	metadata?:string
  // The unique name of the group.
	name?:string
  // Anyone can join open groups, otherwise only admins can accept members.
	open?:boolean
  // The UNIX time when the group was last updated.
	update_time?:string
}

/** A list of users belonging to a group, along with their role. */
export interface ApiGroupUserList {
  // Cursor for the next page of results, if any.
	cursor?:string
  // User-role pairs for a group.
	group_users?:Array<GroupUserListGroupUser>
}

/** Represents a complete leaderboard record with all scores and associated metadata. */
export interface ApiLeaderboardRecord {
  // The UNIX time when the leaderboard record was created.
	create_time?:string
  // The UNIX time when the leaderboard record expires.
	expiry_time?:string
  // The ID of the leaderboard this score belongs to.
	leaderboard_id?:string
  // The maximum number of score updates allowed by the owner.
	max_num_score?:number
  // Metadata.
	metadata?:string
  // The number of submissions to this score record.
	num_score?:number
  // The ID of the score owner, usually a user or group.
	owner_id?:string
  // The rank of this record.
	rank?:string
  // The score value.
	score?:string
  // An optional subscore value.
	subscore?:string
  // The UNIX time when the leaderboard record was updated.
	update_time?:string
  // The username of the score owner, if the owner is a user.
	username?:string
}

/** A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records. */
export interface ApiLeaderboardRecordList {
  // The cursor to send when retrieving the next page, if any.
	next_cursor?:string
  // A batched set of leaderboard records belonging to specified owners.
	owner_records?:Array<ApiLeaderboardRecord>
  // The cursor to send when retrieving the previous page, if any.
	prev_cursor?:string
  // A list of leaderboard records.
	records?:Array<ApiLeaderboardRecord>
}

/** Represents a realtime match. */
export interface ApiMatch {
  // True if it's an server-managed authoritative match, false otherwise.
	authoritative?:boolean
  // 
	handler_name?:string
  // Match label, if any.
	label?:string
  // The ID of the match, can be used to join.
	match_id?:string
  // Current number of users in the match.
	size?:number
  // 
	tick_rate?:number
}

/** A list of realtime matches. */
export interface ApiMatchList {
  // A number of matches corresponding to a list operation.
	matches?:Array<ApiMatch>
}

/** A notification in the server. */
export interface ApiNotification {
  // Category code for this notification.
	code?:number
  // Content of the notification in JSON.
	content?:string
  // The UNIX time when the notification was created.
	create_time?:string
  // ID of the Notification.
	id?:string
  // True if this notification was persisted to the database.
	persistent?:boolean
  // ID of the sender, if a user. Otherwise 'null'.
	sender_id?:string
  // Subject of the notification.
	subject?:string
}

/** A list of validated purchases stored by Nakama. */
export interface ApiPurchaseList {
  // The cursor to send when retrieving the next page, if any.
	cursor?:string
  // The cursor to send when retrieving the next page, if any.
	prev_cursor?:string
  // Stored validated purchases.
	validated_purchases?:Array<ApiValidatedPurchase>
}

/** An object within the storage engine. */
export interface ApiStorageObject {
  // The collection which stores the object.
	collection?:string
  // The UNIX time when the object was created.
	create_time?:string
  // The key of the object within the collection.
	key?:string
  // The read access permissions for the object.
	permission_read?:number
  // The write access permissions for the object.
	permission_write?:number
  // The UNIX time when the object was last updated.
	update_time?:string
  // The user owner of the object.
	user_id?:string
  // The value of the object.
	value?:string
  // The version hash of the object.
	version?:string
}

/** A storage acknowledgement. */
export interface ApiStorageObjectAck {
  // The collection which stores the object.
	collection?:string
  // The key of the object within the collection.
	key?:string
  // The owner of the object.
	user_id?:string
  // The version hash of the object.
	version?:string
}

/** A user in the server. */
export interface ApiUser {
  // The Apple Sign In ID in the user's account.
	apple_id?:string
  // A URL for an avatar image.
	avatar_url?:string
  // The UNIX time when the user was created.
	create_time?:string
  // The display name of the user.
	display_name?:string
  // Number of related edges to this user.
	edge_count?:number
  // The Facebook id in the user's account.
	facebook_id?:string
  // The Facebook Instant Game ID in the user's account.
	facebook_instant_game_id?:string
  // The Apple Game Center in of the user's account.
	gamecenter_id?:string
  // The Google id in the user's account.
	google_id?:string
  // The id of the user's account.
	id?:string
  // The language expected to be a tag which follows the BCP-47 spec.
	lang_tag?:string
  // The location set by the user.
	location?:string
  // Additional information stored as a JSON object.
	metadata?:string
  // Indicates whether the user is currently online.
	online?:boolean
  // The Steam id in the user's account.
	steam_id?:string
  // The timezone set by the user.
	timezone?:string
  // The UNIX time when the user was last updated.
	update_time?:string
  // The username of the user's account.
	username?:string
}

/** A list of groups belonging to a user, along with the user's role in each group. */
export interface ApiUserGroupList {
  // Cursor for the next page of results, if any.
	cursor?:string
  // Group-role pairs for a user.
	user_groups?:Array<UserGroupListUserGroup>
}

/** Validated Purchase stored by Nakama. */
export interface ApiValidatedPurchase {
  // UNIX Timestamp when the receipt validation was stored in DB.
	create_time?:string
  // Whether the purchase was done in production or sandbox environment.
	environment?:ValidatedPurchaseEnvironment
  // Purchase Product ID.
	product_id?:string
  // Raw provider validation response.
	provider_response?:string
  // UNIX Timestamp when the purchase was done.
	purchase_time?:string
  // Whether the purchase had already been validated by Nakama before.
	seen_before?:boolean
  // 
	store?:ValidatedPurchaseStore
  // Purchase Transaction ID.
	transaction_id?:string
  // UNIX Timestamp when the receipt validation was updated in DB.
	update_time?:string
}

/** A user session associated to a stream, usually through a list operation or a join/leave event. */
export interface RealtimeUserPresence {
  // Whether this presence generates persistent data/messages, if applicable for the stream type.
	persistence?:boolean
  // A unique session ID identifying the particular connection, because the user may have many.
	session_id?:string
  // A user-set status message for this stream, if applicable.
	status?:string
  // The user this presence belongs to.
	user_id?:string
  // The username for display purposes.
	username?:string
}

const DEFAULT_HOST = 'http://127.0.0.1:7120';
const DEFAULT_TIMEOUT_MS = 5000;

export class ConfigParams {
  host: string
  timeoutMs: number
}

@Injectable({providedIn: 'root'})
export class ConsoleService {
	private readonly config;

  constructor(private httpClient: HttpClient, @Optional() config: ConfigParams) {
    const defaultConfig: ConfigParams = {
      host: DEFAULT_HOST,
      timeoutMs: DEFAULT_TIMEOUT_MS,
    };
    this.config = config || defaultConfig;
  }

  /** Deletes all data */
  deleteAllData(auth_token: string): Observable<any> {
		const urlPath = `/v2/console`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete (non-recorded) all user accounts. */
  deleteAccounts(auth_token: string): Observable<any> {
		const urlPath = `/v2/console/account`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List (and optionally filter) accounts. */
  listAccounts(auth_token: string, filter?: string, tombstones?: boolean, cursor?: string): Observable<AccountList> {
		const urlPath = `/v2/console/account`;
    let params = new HttpParams();
    if (filter) {
      params = params.set('filter', filter);
    }
    if (tombstones) {
      params = params.set('tombstones', String(tombstones));
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    return this.httpClient.get<AccountList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get a list of the user's wallet transactions. */
  getWalletLedger(auth_token: string, accountId: string, limit?: number, cursor?: string): Observable<WalletLedgerList> {
		accountId = encodeURIComponent(String(accountId))
		const urlPath = `/v2/console/account/${accountId}/wallet`;
    let params = new HttpParams();
    if (limit) {
      params = params.set('limit', String(limit));
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    return this.httpClient.get<WalletLedgerList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete all information stored for a user account. */
  deleteAccount(auth_token: string, id: string, recordDeletion?: boolean): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}`;
    let params = new HttpParams();
    if (recordDeletion) {
      params = params.set('recordDeletion', String(recordDeletion));
    }
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get detailed account information for a single user. */
  getAccount(auth_token: string, id: string): Observable<Account> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}`;
    let params = new HttpParams();
    return this.httpClient.get<Account>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Update one or more fields on a user account. */
  updateAccount(auth_token: string, id: string, body: {avatar_url?: string, custom_id?: string, device_ids?: Map<string, string>, display_name?: string, email?: string, lang_tag?: string, location?: string, metadata?: string, password?: string, timezone?: string, username?: string, wallet?: string}): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Ban a user. */
  banAccount(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/ban`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Export all information stored about a user account. */
  exportAccount(auth_token: string, id: string): Observable<AccountExport> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/export`;
    let params = new HttpParams();
    return this.httpClient.get<AccountExport>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get a user's list of friend relationships. */
  getFriends(auth_token: string, id: string): Observable<ApiFriendList> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/friend`;
    let params = new HttpParams();
    return this.httpClient.get<ApiFriendList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete the friend relationship between two users. */
  deleteFriend(auth_token: string, id: string, friendId: string): Observable<any> {
		id = encodeURIComponent(String(id))
		friendId = encodeURIComponent(String(friendId))
		const urlPath = `/v2/console/account/${id}/friend/${friendId}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get a list of groups the user is a member of. */
  getGroups(auth_token: string, id: string): Observable<ApiUserGroupList> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/group`;
    let params = new HttpParams();
    return this.httpClient.get<ApiUserGroupList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Remove a user from a group. */
  deleteGroupUser(auth_token: string, id: string, groupId: string): Observable<any> {
		id = encodeURIComponent(String(id))
		groupId = encodeURIComponent(String(groupId))
		const urlPath = `/v2/console/account/${id}/group/${groupId}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unban a user. */
  unbanAccount(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unban`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Apple ID from a user account. */
  unlinkApple(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/apple`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the custom ID from a user account. */
  unlinkCustom(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/custom`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the device ID from a user account. */
  unlinkDevice(auth_token: string, id: string, body: {device_id?: string}): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/device`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the email from a user account. */
  unlinkEmail(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/email`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Facebook ID from a user account. */
  unlinkFacebook(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/facebook`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Facebook Instant Game ID from a user account. */
  unlinkFacebookInstantGame(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/facebookinstantgame`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Game Center ID from a user account. */
  unlinkGameCenter(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/gamecenter`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Google ID from a user account. */
  unlinkGoogle(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/google`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Unlink the Steam ID from a user account. */
  unlinkSteam(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/account/${id}/unlink/steam`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete a wallet ledger item. */
  deleteWalletLedger(auth_token: string, id: string, walletId: string): Observable<any> {
		id = encodeURIComponent(String(id))
		walletId = encodeURIComponent(String(walletId))
		const urlPath = `/v2/console/account/${id}/wallet/${walletId}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** API Explorer - list all endpoints */
  listApiEndpoints(auth_token: string): Observable<ApiEndpointList> {
		const urlPath = `/v2/console/api/endpoints`;
    let params = new HttpParams();
    return this.httpClient.get<ApiEndpointList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** API Explorer - call a custom RPC endpoint */
  callRpcEndpoint(auth_token: string, method: string, body: {body?: string, user_id?: string}): Observable<CallApiEndpointResponse> {
		method = encodeURIComponent(String(method))
		const urlPath = `/v2/console/api/endpoints/rpc/${method}`;
    let params = new HttpParams();
    return this.httpClient.post<CallApiEndpointResponse>(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** API Explorer - call an endpoint */
  callApiEndpoint(auth_token: string, method: string, body: {body?: string, user_id?: string}): Observable<CallApiEndpointResponse> {
		method = encodeURIComponent(String(method))
		const urlPath = `/v2/console/api/endpoints/${method}`;
    let params = new HttpParams();
    return this.httpClient.post<CallApiEndpointResponse>(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Authenticate a console user with username and password. */
  authenticate(body: AuthenticateRequest): Observable<ConsoleSession> {
		const urlPath = `/v2/console/authenticate`;
    let params = new HttpParams();
    return this.httpClient.post<ConsoleSession>(this.config.host + urlPath, body, { params: params })
  }

  /** Get server config and configuration warnings. */
  getConfig(auth_token: string): Observable<Config> {
		const urlPath = `/v2/console/config`;
    let params = new HttpParams();
    return this.httpClient.get<Config>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List (and optionally filter) groups. */
  listGroups(auth_token: string, filter?: string, cursor?: string): Observable<GroupList> {
		const urlPath = `/v2/console/group`;
    let params = new HttpParams();
    if (filter) {
      params = params.set('filter', filter);
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    return this.httpClient.get<GroupList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Demote a user from a group. */
  demoteGroupMember(auth_token: string, groupId: string, id: string): Observable<any> {
		groupId = encodeURIComponent(String(groupId))
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${groupId}/account/${id}/demote`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Promote a user from a group. */
  promoteGroupMember(auth_token: string, groupId: string, id: string): Observable<any> {
		groupId = encodeURIComponent(String(groupId))
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${groupId}/account/${id}/promote`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Remove a group. */
  deleteGroup(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${id}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get detailed group information. */
  getGroup(auth_token: string, id: string): Observable<ApiGroup> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${id}`;
    let params = new HttpParams();
    return this.httpClient.get<ApiGroup>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Update one or more fields on a group. */
  updateGroup(auth_token: string, id: string, body: {avatar_url?: string, description?: string, lang_tag?: string, max_count?: number, metadata?: string, name?: string, open?: boolean}): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${id}`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Export all information stored about a group. */
  exportGroup(auth_token: string, id: string): Observable<GroupExport> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${id}/export`;
    let params = new HttpParams();
    return this.httpClient.get<GroupExport>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get a list of members of the group. */
  getMembers(auth_token: string, id: string): Observable<ApiGroupUserList> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/group/${id}/member`;
    let params = new HttpParams();
    return this.httpClient.get<ApiGroupUserList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List leaderboards */
  listLeaderboards(auth_token: string): Observable<LeaderboardList> {
		const urlPath = `/v2/console/leaderboard`;
    let params = new HttpParams();
    return this.httpClient.get<LeaderboardList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete leaderboard */
  deleteLeaderboard(auth_token: string, id: string): Observable<any> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/leaderboard/${id}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get leaderboard. */
  getLeaderboard(auth_token: string, id: string): Observable<Leaderboard> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/leaderboard/${id}`;
    let params = new HttpParams();
    return this.httpClient.get<Leaderboard>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete leaderboard record */
  deleteLeaderboardRecord(auth_token: string, id: string, ownerId: string): Observable<any> {
		id = encodeURIComponent(String(id))
		ownerId = encodeURIComponent(String(ownerId))
		const urlPath = `/v2/console/leaderboard/${id}/owner/${ownerId}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List leaderboard records. */
  listLeaderboardRecords(auth_token: string, leaderboardId: string, ownerIds?: Array<string>, limit?: number, cursor?: string, expiry?: string): Observable<ApiLeaderboardRecordList> {
		leaderboardId = encodeURIComponent(String(leaderboardId))
		const urlPath = `/v2/console/leaderboard/${leaderboardId}/records`;
    let params = new HttpParams();
    if (ownerIds) {
      ownerIds.forEach(e => params = params.append('ownerIds', String(e)))
    }
    if (limit) {
      params = params.set('limit', String(limit));
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    if (expiry) {
      params = params.set('expiry', expiry);
    }
    return this.httpClient.get<ApiLeaderboardRecordList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List ongoing matches */
  listMatches(auth_token: string, limit?: number, authoritative?: boolean, label?: string, minSize?: number, maxSize?: number, query?: string): Observable<ApiMatchList> {
		const urlPath = `/v2/console/match`;
    let params = new HttpParams();
    if (limit) {
      params = params.set('limit', String(limit));
    }
    if (authoritative) {
      params = params.set('authoritative', String(authoritative));
    }
    if (label) {
      params = params.set('label', label);
    }
    if (minSize) {
      params = params.set('minSize', String(minSize));
    }
    if (maxSize) {
      params = params.set('maxSize', String(maxSize));
    }
    if (query) {
      params = params.set('query', query);
    }
    return this.httpClient.get<ApiMatchList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get current state of a running match */
  getMatchState(auth_token: string, id: string): Observable<MatchState> {
		id = encodeURIComponent(String(id))
		const urlPath = `/v2/console/match/${id}/state`;
    let params = new HttpParams();
    return this.httpClient.get<MatchState>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List validated purchases */
  listPurchases(auth_token: string, userId?: string, limit?: number, cursor?: string): Observable<ApiPurchaseList> {
		const urlPath = `/v2/console/purchase`;
    let params = new HttpParams();
    if (userId) {
      params = params.set('userId', userId);
    }
    if (limit) {
      params = params.set('limit', String(limit));
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    return this.httpClient.get<ApiPurchaseList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get runtime info */
  getRuntime(auth_token: string): Observable<RuntimeInfo> {
		const urlPath = `/v2/console/runtime`;
    let params = new HttpParams();
    return this.httpClient.get<RuntimeInfo>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get current status data for all nodes. */
  getStatus(auth_token: string): Observable<StatusList> {
		const urlPath = `/v2/console/status`;
    let params = new HttpParams();
    return this.httpClient.get<StatusList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete all storage data. */
  deleteStorage(auth_token: string): Observable<any> {
		const urlPath = `/v2/console/storage`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List (and optionally filter) storage data. */
  listStorage(auth_token: string, userId?: string, key?: string, collection?: string, cursor?: string): Observable<StorageList> {
		const urlPath = `/v2/console/storage`;
    let params = new HttpParams();
    if (userId) {
      params = params.set('userId', userId);
    }
    if (key) {
      params = params.set('key', key);
    }
    if (collection) {
      params = params.set('collection', collection);
    }
    if (cursor) {
      params = params.set('cursor', cursor);
    }
    return this.httpClient.get<StorageList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List storage collections */
  listStorageCollections(auth_token: string): Observable<StorageCollectionsList> {
		const urlPath = `/v2/console/storage/collections`;
    let params = new HttpParams();
    return this.httpClient.get<StorageCollectionsList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete a storage object. */
  deleteStorageObject(auth_token: string, collection: string, key: string, userId: string, version?: string): Observable<any> {
		collection = encodeURIComponent(String(collection))
		key = encodeURIComponent(String(key))
		userId = encodeURIComponent(String(userId))
		const urlPath = `/v2/console/storage/${collection}/${key}/${userId}`;
    let params = new HttpParams();
    if (version) {
      params = params.set('version', version);
    }
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Get a storage object. */
  getStorage(auth_token: string, collection: string, key: string, userId: string): Observable<ApiStorageObject> {
		collection = encodeURIComponent(String(collection))
		key = encodeURIComponent(String(key))
		userId = encodeURIComponent(String(userId))
		const urlPath = `/v2/console/storage/${collection}/${key}/${userId}`;
    let params = new HttpParams();
    return this.httpClient.get<ApiStorageObject>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Write a new storage object or replace an existing one. */
  writeStorageObject(auth_token: string, collection: string, key: string, userId: string, body: {permission_read?: number, permission_write?: number, value?: string, version?: string}): Observable<ApiStorageObjectAck> {
		collection = encodeURIComponent(String(collection))
		key = encodeURIComponent(String(key))
		userId = encodeURIComponent(String(userId))
		const urlPath = `/v2/console/storage/${collection}/${key}/${userId}`;
    let params = new HttpParams();
    return this.httpClient.put<ApiStorageObjectAck>(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete a storage object. */
  deleteStorageObject2(auth_token: string, collection: string, key: string, userId: string, version: string): Observable<any> {
		collection = encodeURIComponent(String(collection))
		key = encodeURIComponent(String(key))
		userId = encodeURIComponent(String(userId))
		version = encodeURIComponent(String(version))
		const urlPath = `/v2/console/storage/${collection}/${key}/${userId}/${version}`;
    let params = new HttpParams();
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Delete console user. */
  deleteUser(auth_token: string, username?: string): Observable<any> {
		const urlPath = `/v2/console/user`;
    let params = new HttpParams();
    if (username) {
      params = params.set('username', username);
    }
    return this.httpClient.delete(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** List (and optionally filter) users. */
  listUsers(auth_token: string): Observable<UserList> {
		const urlPath = `/v2/console/user`;
    let params = new HttpParams();
    return this.httpClient.get<UserList>(this.config.host + urlPath, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  /** Add a new console user. */
  addUser(auth_token: string, body: AddUserRequest): Observable<any> {
		const urlPath = `/v2/console/user`;
    let params = new HttpParams();
    return this.httpClient.post(this.config.host + urlPath, body, { params: params, headers: this.getTokenAuthHeaders(auth_token) })
  }

  private getTokenAuthHeaders(token: string): HttpHeaders {
    return new HttpHeaders().set('Authorization', 'Bearer ' + token);
  }

  private getBasicAuthHeaders(username: string, password: string): HttpHeaders {
    return new HttpHeaders().set('Authorization', 'Basic ' + btoa(username + ':' + password));
  }
}
